From 1e90288948390fc4ac1fea647e291f7aa8a93d20 Mon Sep 17 00:00:00 2001
From: dgsudharsan <sudharsand@nvidia.com>
Date: Thu, 24 Oct 2024 00:02:43 +0000
Subject: [PATCH] bgp mpath improvements


diff --git a/bgpd/bgp_damp.c b/bgpd/bgp_damp.c
index 3cf5ffe7fe..e8b446808d 100644
--- a/bgpd/bgp_damp.c
+++ b/bgpd/bgp_damp.c
@@ -165,7 +165,7 @@ static void bgp_reuse_timer(struct thread *t)
 				bgp_aggregate_increment(
 					bgp, bgp_dest_get_prefix(bdi->dest),
 					bdi->path, bdi->afi, bdi->safi);
-				bgp_process(bgp, bdi->dest, bdi->afi,
+				bgp_process(bgp, bdi->dest, bdi->path, bdi->afi,
 					    bdi->safi);
 			}
 
@@ -321,8 +321,10 @@ void bgp_damp_info_free(struct bgp_damp_info *bdi, int withdraw, afi_t afi,
 	bgp_path_info_unset_flag(bdi->dest, path,
 				 BGP_PATH_HISTORY | BGP_PATH_DAMPED);
 
-	if (bdi->lastrecord == BGP_RECORD_WITHDRAW && withdraw)
+	if (bdi->lastrecord == BGP_RECORD_WITHDRAW && withdraw) {
 		bgp_path_info_delete(bdi->dest, path);
+		bgp_process(path->peer->bgp, bdi->dest, path, afi, safi);
+	}
 
 	XFREE(MTYPE_BGP_DAMP_INFO, bdi);
 }
diff --git a/bgpd/bgp_evpn.c b/bgpd/bgp_evpn.c
index 34128e7c19..279498f67d 100644
--- a/bgpd/bgp_evpn.c
+++ b/bgpd/bgp_evpn.c
@@ -1390,7 +1390,7 @@ static void evpn_delete_old_local_route(struct bgp *bgp, struct bgpevpn *vpn,
 		 * this table.
 		 */
 		if (pi)
-			bgp_process(bgp, global_dest, afi, safi);
+			bgp_process(bgp, global_dest, pi, afi, safi);
 		bgp_dest_unlock_node(global_dest);
 	}
 
@@ -1404,14 +1404,29 @@ static void evpn_delete_old_local_route(struct bgp *bgp, struct bgpevpn *vpn,
  * Note: vpn is NULL for local EAD-ES routes.
  */
 int evpn_route_select_install(struct bgp *bgp, struct bgpevpn *vpn,
-				     struct bgp_dest *dest)
+			      struct bgp_dest *dest, struct bgp_path_info *pi)
 {
-	struct bgp_path_info *old_select, *new_select;
+	struct bgp_path_info *old_select, *new_select, *first;
 	struct bgp_path_info_pair old_and_new;
 	afi_t afi = AFI_L2VPN;
 	safi_t safi = SAFI_EVPN;
 	int ret = 0;
 
+	first = bgp_dest_get_bgp_path_info(dest);
+	SET_FLAG(pi->flags, BGP_PATH_UNSORTED);
+	if (pi != first) {
+		if (pi->next)
+			pi->next->prev = pi->prev;
+		if (pi->prev)
+			pi->prev->next = pi->next;
+
+		if (first)
+			first->prev = pi;
+		pi->next = first;
+		pi->prev = NULL;
+		bgp_dest_set_bgp_path_info(dest, pi);
+	}
+
 	/* Compute the best path. */
 	bgp_best_selection(bgp, dest, &bgp->maxpaths[afi][safi], &old_and_new,
 			   afi, safi);
@@ -1547,7 +1562,8 @@ static struct bgp_path_info *bgp_evpn_route_get_local_path(
 static int update_evpn_type5_route_entry(struct bgp *bgp_evpn,
 					 struct bgp *bgp_vrf, afi_t afi,
 					 safi_t safi, struct bgp_dest *dest,
-					 struct attr *attr, int *route_changed)
+					 struct attr *attr, int *route_changed,
+					 struct bgp_path_info **entry)
 {
 	struct attr *attr_new = NULL;
 	struct bgp_path_info *pi = NULL;
@@ -1590,8 +1606,8 @@ static int update_evpn_type5_route_entry(struct bgp *bgp_evpn,
 
 		/* add the route entry to route node*/
 		bgp_path_info_add(dest, pi);
+		*entry = pi;
 	} else {
-
 		tmp_pi = local_pi;
 		if (!attrhash_cmp(tmp_pi->attr, attr)) {
 
@@ -1613,6 +1629,7 @@ static int update_evpn_type5_route_entry(struct bgp *bgp_evpn,
 			tmp_pi->attr = attr_new;
 			tmp_pi->uptime = monotime(NULL);
 		}
+		*entry = local_pi;
 	}
 	return 0;
 }
@@ -1628,6 +1645,7 @@ static int update_evpn_type5_route(struct bgp *bgp_vrf, struct prefix_evpn *evp,
 	struct bgp_dest *dest = NULL;
 	struct bgp *bgp_evpn = NULL;
 	int route_changed = 0;
+	struct bgp_path_info *pi = NULL;
 
 	bgp_evpn = bgp_get_evpn();
 	if (!bgp_evpn)
@@ -1706,11 +1724,11 @@ static int update_evpn_type5_route(struct bgp *bgp_vrf, struct prefix_evpn *evp,
 
 	/* create or update the route entry within the route node */
 	update_evpn_type5_route_entry(bgp_evpn, bgp_vrf, afi, safi, dest, &attr,
-				      &route_changed);
+				      &route_changed, &pi);
 
 	/* schedule for processing and unlock node */
 	if (route_changed) {
-		bgp_process(bgp_evpn, dest, afi, safi);
+		bgp_process(bgp_evpn, dest, pi, afi, safi);
 		bgp_dest_unlock_node(dest);
 	}
 
@@ -2209,7 +2227,7 @@ static int update_evpn_route(struct bgp *bgp, struct bgpevpn *vpn,
         * route would win, and we should evict the defunct local route
         * and (re)install the remote route into zebra.
 	*/
-	evpn_route_select_install(bgp, vpn, dest);
+	evpn_route_select_install(bgp, vpn, dest, pi);
 	/*
 	 * If the new local route was not selected evict it and tell zebra
 	 * to re-add the best remote dest. BGP doesn't retain non-best local
@@ -2263,7 +2281,7 @@ static int update_evpn_route(struct bgp *bgp, struct bgpevpn *vpn,
 			false /* setup_sync */, NULL /* old_is_sync */);
 
 		/* Schedule for processing and unlock node. */
-		bgp_process(bgp, dest, afi, safi);
+		bgp_process(bgp, dest, global_pi, afi, safi);
 		bgp_dest_unlock_node(dest);
 	}
 
@@ -2321,7 +2339,7 @@ static int delete_evpn_type5_route(struct bgp *bgp_vrf, struct prefix_evpn *evp)
 
 	delete_evpn_route_entry(bgp_evpn, afi, safi, dest, &pi);
 	if (pi)
-		bgp_process(bgp_evpn, dest, afi, safi);
+		bgp_process(bgp_evpn, dest, pi, afi, safi);
 	bgp_dest_unlock_node(dest);
 	return 0;
 }
@@ -2361,7 +2379,7 @@ static int delete_evpn_route(struct bgp *bgp, struct bgpevpn *vpn,
 		 * this table.
 		 */
 		if (pi)
-			bgp_process(bgp, global_dest, afi, safi);
+			bgp_process(bgp, global_dest, pi, afi, safi);
 		bgp_dest_unlock_node(global_dest);
 	}
 
@@ -2369,8 +2387,8 @@ static int delete_evpn_route(struct bgp *bgp, struct bgpevpn *vpn,
 	 */
 	delete_evpn_route_entry(bgp, afi, safi, dest, &pi);
 	if (pi) {
-		bgp_path_info_reap(dest, pi);
-		evpn_route_select_install(bgp, vpn, dest);
+		bgp_path_info_delete(dest, pi);
+		evpn_route_select_install(bgp, vpn, dest, pi);
 	}
 	bgp_dest_unlock_node(dest);
 
@@ -2476,7 +2494,7 @@ void bgp_evpn_update_type2_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 	 * advertised to peers; otherwise, ensure it is evicted and
 	 * (re)install the remote route into zebra.
 	 */
-	evpn_route_select_install(bgp, vpn, dest);
+	evpn_route_select_install(bgp, vpn, dest, pi);
 
 	if (CHECK_FLAG(pi->flags, BGP_PATH_REMOVED)) {
 		route_change = 0;
@@ -2523,7 +2541,7 @@ void bgp_evpn_update_type2_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 			NULL /* old_is_sync */);
 
 		/* Schedule for processing and unlock node. */
-		bgp_process(bgp, global_dest, afi, safi);
+		bgp_process(bgp, global_dest, global_pi, afi, safi);
 		bgp_dest_unlock_node(global_dest);
 	}
 
@@ -2608,7 +2626,7 @@ static void delete_global_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
 
 			delete_evpn_route_entry(bgp, afi, safi, dest, &pi);
 			if (pi)
-				bgp_process(bgp, dest, afi, safi);
+				bgp_process(bgp, dest, pi, afi, safi);
 		}
 
 		/* Unlock RD node. */
@@ -3029,7 +3047,7 @@ static int install_evpn_route_entry_in_vrf(struct bgp *bgp_vrf,
 				safi);
 
 	/* Perform route selection and update zebra, if required. */
-	bgp_process(bgp_vrf, dest, afi, safi);
+	bgp_process(bgp_vrf, dest, pi, afi, safi);
 
 	/* Process for route leaking. */
 	vpn_leak_from_vrf_update(bgp_get_default(), bgp_vrf, pi);
@@ -3129,7 +3147,7 @@ static int install_evpn_route_entry_in_vni_common(
 	bgp_evpn_remote_ip_hash_add(vpn, pi);
 
 	/* Perform route selection and update zebra, if required. */
-	ret = evpn_route_select_install(bgp, vpn, dest);
+	ret = evpn_route_select_install(bgp, vpn, dest, pi);
 
 	/* if the best path is a local path with a non-zero ES
 	 * sync info against the local path may need to be updated
@@ -3170,7 +3188,7 @@ static int uninstall_evpn_route_entry_in_vni_common(
 	bgp_path_info_delete(dest, pi);
 
 	/* Perform route selection and update zebra, if required. */
-	ret = evpn_route_select_install(bgp, vpn, dest);
+	ret = evpn_route_select_install(bgp, vpn, dest, pi);
 
 	/* if the best path is a local path with a non-zero ES
 	 * sync info against the local path may need to be updated
@@ -3362,7 +3380,7 @@ static int uninstall_evpn_route_entry_in_vrf(struct bgp *bgp_vrf,
 	bgp_evpn_path_nh_del(bgp_vrf, pi);
 
 	/* Perform route selection and update zebra, if required. */
-	bgp_process(bgp_vrf, dest, afi, safi);
+	bgp_process(bgp_vrf, dest, pi, afi, safi);
 
 	/* Unlock route node. */
 	bgp_dest_unlock_node(dest);
@@ -4287,7 +4305,7 @@ static void update_advertise_vni_route(struct bgp *bgp, struct bgpevpn *vpn,
 	}
 
 	/* Schedule for processing and unlock node. */
-	bgp_process(bgp, global_dest, afi, safi);
+	bgp_process(bgp, global_dest, global_pi, afi, safi);
 	bgp_dest_unlock_node(global_dest);
 }
 
@@ -4337,7 +4355,7 @@ static void update_advertise_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
 			false /* setup_sync */, NULL /* old_is_sync */);
 
 		/* Schedule for processing and unlock node. */
-		bgp_process(bgp, global_dest, afi, safi);
+		bgp_process(bgp, global_dest, pi, afi, safi);
 		bgp_dest_unlock_node(global_dest);
 	}
 
@@ -4382,7 +4400,7 @@ static int delete_withdraw_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
 		 * this table.
 		 */
 		if (pi)
-			bgp_process(bgp, global_dest, afi, safi);
+			bgp_process(bgp, global_dest, pi, afi, safi);
 		bgp_dest_unlock_node(global_dest);
 	}
 
@@ -6153,9 +6171,10 @@ int bgp_filter_evpn_routes_upon_martian_nh_change(struct bgp *bgp)
 
 		for (dest = bgp_table_top(table); dest;
 		     dest = bgp_route_next(dest)) {
+			struct bgp_path_info *next;
 
-			for (pi = bgp_dest_get_bgp_path_info(dest); pi;
-			     pi = pi->next) {
+			for (pi = bgp_dest_get_bgp_path_info(dest);
+			     (pi != NULL) && (next = pi->next, 1); pi = next) {
 
 				/* Consider "valid" remote routes applicable for
 				 * this VNI. */
diff --git a/bgpd/bgp_evpn_mh.c b/bgpd/bgp_evpn_mh.c
index 40687c558d..e8bd5b9aaa 100644
--- a/bgpd/bgp_evpn_mh.c
+++ b/bgpd/bgp_evpn_mh.c
@@ -103,7 +103,8 @@ static void bgp_evpn_path_nh_unlink(struct bgp_path_evpn_nh_info *nh_info);
  */
 static int bgp_evpn_es_route_select_install(struct bgp *bgp,
 					    struct bgp_evpn_es *es,
-					    struct bgp_dest *dest)
+					    struct bgp_dest *dest,
+					    struct bgp_path_info *pi)
 {
 	int ret = 0;
 	int zret = 0;
@@ -113,6 +114,8 @@ static int bgp_evpn_es_route_select_install(struct bgp *bgp,
 	struct bgp_path_info *new_select; /* new best */
 	struct bgp_path_info_pair old_and_new;
 
+	SET_FLAG(pi->flags, BGP_PATH_UNSORTED);
+
 	/* Compute the best path. */
 	bgp_best_selection(bgp, dest, &bgp->maxpaths[afi][safi], &old_and_new,
 			   afi, safi);
@@ -239,7 +242,7 @@ static int bgp_evpn_es_route_install(struct bgp *bgp,
 	}
 
 	/* Perform route selection and update zebra, if required. */
-	ret = bgp_evpn_es_route_select_install(bgp, es, dest);
+	ret = bgp_evpn_es_route_select_install(bgp, es, dest, pi);
 
 	bgp_dest_unlock_node(dest);
 
@@ -280,7 +283,7 @@ static int bgp_evpn_es_route_uninstall(struct bgp *bgp, struct bgp_evpn_es *es,
 	bgp_path_info_delete(dest, pi);
 
 	/* Perform route selection and update zebra, if required. */
-	ret = bgp_evpn_es_route_select_install(bgp, es, dest);
+	ret = bgp_evpn_es_route_select_install(bgp, es, dest, pi);
 
 	/* Unlock route node. */
 	bgp_dest_unlock_node(dest);
@@ -511,7 +514,7 @@ static int bgp_evpn_mh_route_delete(struct bgp *bgp, struct bgp_evpn_es *es,
 		 * this table.
 		 */
 		if (pi)
-			bgp_process(bgp, global_dest, afi, safi);
+			bgp_process(bgp, global_dest, pi, afi, safi);
 		bgp_dest_unlock_node(global_dest);
 	}
 
@@ -559,7 +562,7 @@ int delete_global_ead_evi_routes(struct bgp *bgp, struct bgpevpn *vpn)
 
 			delete_evpn_route_entry(bgp, afi, safi, rn, &pi);
 			if (pi)
-				bgp_process(bgp, rn, afi, safi);
+				bgp_process(bgp, rn, pi, afi, safi);
 		}
 	}
 
@@ -665,7 +668,7 @@ static int bgp_evpn_type4_route_update(struct bgp *bgp,
 	 * this is just to set the flags correctly
 	 * as local route in the ES always wins.
 	 */
-	bgp_evpn_es_route_select_install(bgp, es, dest);
+	bgp_evpn_es_route_select_install(bgp, es, dest, pi);
 	bgp_dest_unlock_node(dest);
 
 	/* If this is a new route or some attribute has changed, export the
@@ -683,7 +686,7 @@ static int bgp_evpn_type4_route_update(struct bgp *bgp,
 					 attr_new, &global_pi, &route_changed);
 
 		/* Schedule for processing and unlock node. */
-		bgp_process(bgp, dest, afi, safi);
+		bgp_process(bgp, dest, global_pi, afi, safi);
 		bgp_dest_unlock_node(dest);
 	}
 
@@ -1005,7 +1008,7 @@ static int bgp_evpn_type1_route_update(struct bgp *bgp, struct bgp_evpn_es *es,
 	 * this is just to set the flags correctly as local route in
 	 * the ES always wins.
 	 */
-	evpn_route_select_install(bgp, vpn, dest);
+	evpn_route_select_install(bgp, vpn, dest, pi);
 	bgp_dest_unlock_node(dest);
 
 	/* If this is a new route or some attribute has changed, export the
@@ -1022,7 +1025,7 @@ static int bgp_evpn_type1_route_update(struct bgp *bgp, struct bgp_evpn_es *es,
 					 attr_new, &global_pi, &route_changed);
 
 		/* Schedule for processing and unlock node. */
-		bgp_process(bgp, dest, afi, safi);
+		bgp_process(bgp, dest, global_pi, afi, safi);
 		bgp_dest_unlock_node(dest);
 	}
 
diff --git a/bgpd/bgp_evpn_private.h b/bgpd/bgp_evpn_private.h
index 3f18e4e9f1..72d1a11817 100644
--- a/bgpd/bgp_evpn_private.h
+++ b/bgpd/bgp_evpn_private.h
@@ -722,7 +722,8 @@ extern void delete_evpn_route_entry(struct bgp *bgp, afi_t afi, safi_t safi,
 				    struct bgp_path_info **pi);
 int vni_list_cmp(void *p1, void *p2);
 extern int evpn_route_select_install(struct bgp *bgp, struct bgpevpn *vpn,
-				     struct bgp_dest *dest);
+				     struct bgp_dest *dest,
+				     struct bgp_path_info *pi);
 extern struct bgp_dest *
 bgp_evpn_global_node_get(struct bgp_table *table, afi_t afi, safi_t safi,
 			 const struct prefix_evpn *evp, struct prefix_rd *prd,
diff --git a/bgpd/bgp_label.c b/bgpd/bgp_label.c
index 64d1ff70ca..210598768c 100644
--- a/bgpd/bgp_label.c
+++ b/bgpd/bgp_label.c
@@ -89,7 +89,7 @@ int bgp_parse_fec_update(void)
 		bgp_set_valid_label(&dest->local_label);
 	}
 	SET_FLAG(dest->flags, BGP_NODE_LABEL_CHANGED);
-	bgp_process(bgp, dest, afi, safi);
+	bgp_process(bgp, dest, NULL, afi, safi);
 	bgp_dest_unlock_node(dest);
 	return 1;
 }
diff --git a/bgpd/bgp_mpath.c b/bgpd/bgp_mpath.c
index 32a5e14b11..7e44ee75ca 100644
--- a/bgpd/bgp_mpath.c
+++ b/bgpd/bgp_mpath.c
@@ -1,15 +1,17 @@
 /*
  * BGP Multipath
  * Copyright (C) 2010 Google Inc.
+ *               2024 Nvidia Corporation
+ *                    Donald Sharp
  *
- * This file is part of Quagga
+ * This file is part of FRR
  *
- * Quagga is free software; you can redistribute it and/or modify it
+ * FRR is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; either version 2, or (at your option) any
  * later version.
  *
- * Quagga is distributed in the hope that it will be useful, but
+ * FRR is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
@@ -198,78 +200,6 @@ int bgp_path_info_nexthop_cmp(struct bgp_path_info *bpi1,
 	return compare;
 }
 
-/*
- * bgp_path_info_mpath_cmp
- *
- * This function determines our multipath list ordering. By ordering
- * the list we can deterministically select which paths are included
- * in the multipath set. The ordering also helps in detecting changes
- * in the multipath selection so we can detect whether to send an
- * update to zebra.
- *
- * The order of paths is determined first by received nexthop, and then
- * by peer address if the nexthops are the same.
- */
-static int bgp_path_info_mpath_cmp(void *val1, void *val2)
-{
-	struct bgp_path_info *bpi1, *bpi2;
-	int compare;
-
-	bpi1 = val1;
-	bpi2 = val2;
-
-	compare = bgp_path_info_nexthop_cmp(bpi1, bpi2);
-
-	if (!compare) {
-		if (!bpi1->peer->su_remote && !bpi2->peer->su_remote)
-			compare = 0;
-		else if (!bpi1->peer->su_remote)
-			compare = 1;
-		else if (!bpi2->peer->su_remote)
-			compare = -1;
-		else
-			compare = sockunion_cmp(bpi1->peer->su_remote,
-						bpi2->peer->su_remote);
-	}
-
-	return compare;
-}
-
-/*
- * bgp_mp_list_init
- *
- * Initialize the mp_list, which holds the list of multipaths
- * selected by bgp_best_selection
- */
-void bgp_mp_list_init(struct list *mp_list)
-{
-	assert(mp_list);
-	memset(mp_list, 0, sizeof(struct list));
-	mp_list->cmp = bgp_path_info_mpath_cmp;
-}
-
-/*
- * bgp_mp_list_clear
- *
- * Clears all entries out of the mp_list
- */
-void bgp_mp_list_clear(struct list *mp_list)
-{
-	assert(mp_list);
-	list_delete_all_node(mp_list);
-}
-
-/*
- * bgp_mp_list_add
- *
- * Adds a multipath entry to the mp_list
- */
-void bgp_mp_list_add(struct list *mp_list, struct bgp_path_info *mpinfo)
-{
-	assert(mp_list && mpinfo);
-	listnode_add_sort(mp_list, mpinfo);
-}
-
 /*
  * bgp_path_info_mpath_new
  *
@@ -282,6 +212,7 @@ static struct bgp_path_info_mpath *bgp_path_info_mpath_new(void)
 	new_mpath = XCALLOC(MTYPE_BGP_MPATH_INFO,
 			    sizeof(struct bgp_path_info_mpath));
 
+	new_mpath->mp_count = 1;
 	return new_mpath;
 }
 
@@ -295,6 +226,8 @@ void bgp_path_info_mpath_free(struct bgp_path_info_mpath **mpath)
 	if (mpath && *mpath) {
 		if ((*mpath)->mp_attr)
 			bgp_attr_unintern(&(*mpath)->mp_attr);
+		(*mpath)->mp_attr = NULL;
+
 		XFREE(MTYPE_BGP_MPATH_INFO, *mpath);
 	}
 }
@@ -321,49 +254,6 @@ bgp_path_info_mpath_get(struct bgp_path_info *path)
 	return path->mpath;
 }
 
-/*
- * bgp_path_info_mpath_enqueue
- *
- * Enqueue a path onto the multipath list given the previous multipath
- * list entry
- */
-static void bgp_path_info_mpath_enqueue(struct bgp_path_info *prev_info,
-					struct bgp_path_info *path)
-{
-	struct bgp_path_info_mpath *prev, *mpath;
-
-	prev = bgp_path_info_mpath_get(prev_info);
-	mpath = bgp_path_info_mpath_get(path);
-	if (!prev || !mpath)
-		return;
-
-	mpath->mp_next = prev->mp_next;
-	mpath->mp_prev = prev;
-	if (prev->mp_next)
-		prev->mp_next->mp_prev = mpath;
-	prev->mp_next = mpath;
-
-	SET_FLAG(path->flags, BGP_PATH_MULTIPATH);
-}
-
-/*
- * bgp_path_info_mpath_dequeue
- *
- * Remove a path from the multipath list
- */
-void bgp_path_info_mpath_dequeue(struct bgp_path_info *path)
-{
-	struct bgp_path_info_mpath *mpath = path->mpath;
-	if (!mpath)
-		return;
-	if (mpath->mp_prev)
-		mpath->mp_prev->mp_next = mpath->mp_next;
-	if (mpath->mp_next)
-		mpath->mp_next->mp_prev = mpath->mp_prev;
-	mpath->mp_next = mpath->mp_prev = NULL;
-	UNSET_FLAG(path->flags, BGP_PATH_MULTIPATH);
-}
-
 /*
  * bgp_path_info_mpath_next
  *
@@ -371,9 +261,16 @@ void bgp_path_info_mpath_dequeue(struct bgp_path_info *path)
  */
 struct bgp_path_info *bgp_path_info_mpath_next(struct bgp_path_info *path)
 {
-	if (!path->mpath || !path->mpath->mp_next)
-		return NULL;
-	return path->mpath->mp_next->mp_info;
+	path = path->next;
+
+	while (path) {
+		if (CHECK_FLAG(path->flags, BGP_PATH_MULTIPATH))
+			return path;
+
+		path = path->next;
+	}
+
+	return NULL;
 }
 
 /*
@@ -394,7 +291,8 @@ struct bgp_path_info *bgp_path_info_mpath_first(struct bgp_path_info *path)
 uint32_t bgp_path_info_mpath_count(struct bgp_path_info *path)
 {
 	if (!path->mpath)
-		return 0;
+		return 1;
+
 	return path->mpath->mp_count;
 }
 
@@ -419,6 +317,10 @@ static void bgp_path_info_mpath_count_set(struct bgp_path_info *path,
  * bgp_path_info_mpath_lb_update
  *
  * Update cumulative info related to link-bandwidth
+ *
+ * This is only set on the first mpath of the list
+ * as such we should UNSET the flags when removing
+ * to ensure nothing accidently happens
  */
 static void bgp_path_info_mpath_lb_update(struct bgp_path_info *path, bool set,
 					  bool all_paths_lb, uint64_t cum_bw)
@@ -480,10 +382,10 @@ bool bgp_path_info_mpath_chkwtd(struct bgp *bgp, struct bgp_path_info *path)
 	 */
 	if (bgp->lb_handling != BGP_LINK_BW_SKIP_MISSING &&
 	    bgp->lb_handling != BGP_LINK_BW_DEFWT_4_MISSING)
-		return (path->mpath->mp_flags & BGP_MP_LB_ALL);
+		return CHECK_FLAG(path->mpath->mp_flags, BGP_MP_LB_ALL);
 
 	/* At least one path should have bandwidth. */
-	return (path->mpath->mp_flags & BGP_MP_LB_PRESENT);
+	return CHECK_FLAG(path->mpath->mp_flags, BGP_MP_LB_PRESENT);
 }
 
 /*
@@ -519,59 +421,56 @@ static void bgp_path_info_mpath_attr_set(struct bgp_path_info *path,
 /*
  * bgp_path_info_mpath_update
  *
- * Compare and sync up the multipath list with the mp_list generated by
- * bgp_best_selection
+ * Compare and sync up the multipath flags with what was choosen
+ * in best selection
  */
 void bgp_path_info_mpath_update(struct bgp *bgp, struct bgp_dest *dest,
 				struct bgp_path_info *new_best,
 				struct bgp_path_info *old_best,
-				struct list *mp_list,
+				uint32_t num_candidates,
 				struct bgp_maxpaths_cfg *mpath_cfg)
 {
 	uint16_t maxpaths, mpath_count, old_mpath_count;
 	uint32_t bwval;
 	uint64_t cum_bw, old_cum_bw;
-	struct listnode *mp_node, *mp_next_node;
-	struct bgp_path_info *cur_mpath, *new_mpath, *next_mpath, *prev_mpath;
-	int mpath_changed, debug;
+	struct bgp_path_info *cur_iterator = NULL;
+	bool mpath_changed, debug;
 	bool all_paths_lb;
 	char path_buf[PATH_ADDPATH_STR_BUFFER];
+	bool old_mpath, new_mpath;
 
-	mpath_changed = 0;
+	mpath_changed = false;
 	maxpaths = multipath_num;
 	mpath_count = 0;
-	cur_mpath = NULL;
 	old_mpath_count = 0;
 	old_cum_bw = cum_bw = 0;
-	prev_mpath = new_best;
-	mp_node = listhead(mp_list);
 	debug = bgp_debug_bestpath(dest);
 
-	if (new_best) {
-		mpath_count++;
-		if (new_best != old_best)
-			bgp_path_info_mpath_dequeue(new_best);
-		maxpaths = (new_best->peer->sort == BGP_PEER_IBGP)
-				   ? mpath_cfg->maxpaths_ibgp
-				   : mpath_cfg->maxpaths_ebgp;
-	}
-
 	if (old_best) {
-		cur_mpath = bgp_path_info_mpath_first(old_best);
 		old_mpath_count = bgp_path_info_mpath_count(old_best);
+		if (old_mpath_count == 1)
+			SET_FLAG(old_best->flags, BGP_PATH_MULTIPATH);
 		old_cum_bw = bgp_path_info_mpath_cumbw(old_best);
 		bgp_path_info_mpath_count_set(old_best, 0);
 		bgp_path_info_mpath_lb_update(old_best, false, false, 0);
-		bgp_path_info_mpath_dequeue(old_best);
+		bgp_path_info_mpath_free(&old_best->mpath);
+		old_best->mpath = NULL;
+	}
+
+	if (new_best) {
+		maxpaths = (new_best->peer->sort == BGP_PEER_IBGP)
+				   ? mpath_cfg->maxpaths_ibgp
+				   : mpath_cfg->maxpaths_ebgp;
+		cur_iterator = new_best;
 	}
 
 	if (debug)
 		zlog_debug(
-			"%pRN(%s): starting mpath update, newbest %s num candidates %d old-mpath-count %d old-cum-bw %" PRIu64,
-			bgp_dest_to_rnode(dest), bgp->name_pretty,
+			"%pBD(%s): starting mpath update, newbest %s num candidates %d old-mpath-count %d old-cum-bw %" PRIu64
+			" maxpaths set %u",
+			dest, bgp->name_pretty,
 			new_best ? new_best->peer->host : "NONE",
-			mp_list ? listcount(mp_list) : 0, old_mpath_count,
-			old_cum_bw);
+			num_candidates, old_mpath_count, old_cum_bw, maxpaths);
 
 	/*
 	 * We perform an ordered walk through both lists in parallel.
@@ -585,169 +484,102 @@ void bgp_path_info_mpath_update(struct bgp *bgp, struct bgp_dest *dest,
 	 * to skip over it
 	 */
 	all_paths_lb = true; /* We'll reset if any path doesn't have LB. */
-	while (mp_node || cur_mpath) {
-		struct bgp_path_info *tmp_info;
 
+	while (cur_iterator) {
+		old_mpath = CHECK_FLAG(cur_iterator->flags, BGP_PATH_MULTIPATH);
+		new_mpath =
+			CHECK_FLAG(cur_iterator->flags, BGP_PATH_MULTIPATH_NEW);
+
+		UNSET_FLAG(cur_iterator->flags, BGP_PATH_MULTIPATH_NEW);
 		/*
-		 * We can bail out of this loop if all existing paths on the
-		 * multipath list have been visited (for cleanup purposes) and
-		 * the maxpath requirement is fulfulled
+		 * If the current mpath count is equal to the number of
+		 * maxpaths that can be used then we can bail, after
+		 * we clean up the flags associated with the rest of the
+		 * bestpaths
 		 */
-		if (!cur_mpath && (mpath_count >= maxpaths))
+		if (mpath_count >= maxpaths) {
+			while (cur_iterator) {
+				UNSET_FLAG(cur_iterator->flags,
+					   BGP_PATH_MULTIPATH);
+				UNSET_FLAG(cur_iterator->flags,
+					   BGP_PATH_MULTIPATH_NEW);
+
+				cur_iterator = cur_iterator->next;
+			}
 			break;
 
-		mp_next_node = mp_node ? listnextnode(mp_node) : NULL;
-		next_mpath =
-			cur_mpath ? bgp_path_info_mpath_next(cur_mpath) : NULL;
-		tmp_info = mp_node ? listgetdata(mp_node) : NULL;
+			if (debug)
+				zlog_debug(
+					"%pBD(%s): Mpath count %u is equal to maximum paths allowed, finished comparision for MPATHS",
+					dest, bgp->name_pretty, mpath_count);
+		}
 
 		if (debug)
 			zlog_debug(
-				"%pRN(%s): comparing candidate %s with existing mpath %s",
-				bgp_dest_to_rnode(dest), bgp->name_pretty,
-				tmp_info ? tmp_info->peer->host : "NONE",
-				cur_mpath ? cur_mpath->peer->host : "NONE");
-
+				"%pBD(%s): Candidate %s old_mpath: %u new_mpath: %u, Nexthop %pI4 current mpath count: %u",
+				dest, bgp->name_pretty,
+				cur_iterator->peer->host, old_mpath, new_mpath,
+				&cur_iterator->attr->nexthop, mpath_count);
 		/*
-		 * If equal, the path was a multipath and is still a multipath.
-		 * Insert onto new multipath list if maxpaths allows.
+		 * There is nothing to do if the cur_iterator is neither a old
+		 * path or a new path
 		 */
-		if (mp_node && (listgetdata(mp_node) == cur_mpath)) {
-			list_delete_node(mp_list, mp_node);
-			bgp_path_info_mpath_dequeue(cur_mpath);
-			if ((mpath_count < maxpaths)
-			    && prev_mpath
-			    && bgp_path_info_nexthop_cmp(prev_mpath,
-							 cur_mpath)) {
-				bgp_path_info_mpath_enqueue(prev_mpath,
-							    cur_mpath);
-				prev_mpath = cur_mpath;
-				mpath_count++;
-				if (ecommunity_linkbw_present(
-					    bgp_attr_get_ecommunity(
-						    cur_mpath->attr),
-					    &bwval))
-					cum_bw += bwval;
-				else
-					all_paths_lb = false;
-				if (debug) {
-					bgp_path_info_path_with_addpath_rx_str(
-						cur_mpath, path_buf,
-						sizeof(path_buf));
-					zlog_debug(
-						"%pRN: %s is still multipath, cur count %d",
-						bgp_dest_to_rnode(dest),
-						path_buf, mpath_count);
-				}
-			} else {
-				mpath_changed = 1;
-				if (debug) {
-					bgp_path_info_path_with_addpath_rx_str(
-						cur_mpath, path_buf,
-						sizeof(path_buf));
-					zlog_debug(
-						"%pRN: remove mpath %s nexthop %pI4, cur count %d",
-						bgp_dest_to_rnode(dest),
-						path_buf,
-						&cur_mpath->attr->nexthop,
-						mpath_count);
-				}
-			}
-			mp_node = mp_next_node;
-			cur_mpath = next_mpath;
+		if (!old_mpath && !new_mpath) {
+			UNSET_FLAG(cur_iterator->flags, BGP_PATH_MULTIPATH);
+			cur_iterator = cur_iterator->next;
 			continue;
 		}
 
-		if (cur_mpath
-		    && (!mp_node
-			|| (bgp_path_info_mpath_cmp(cur_mpath,
-						    listgetdata(mp_node))
-			    < 0))) {
-			/*
-			 * If here, we have an old multipath and either the
-			 * mp_list
-			 * is finished or the next mp_node points to a later
-			 * multipath, so we need to purge this path from the
-			 * multipath list
-			 */
-			bgp_path_info_mpath_dequeue(cur_mpath);
-			mpath_changed = 1;
+		if (new_mpath) {
+			mpath_count++;
+
+			if (cur_iterator != new_best)
+				SET_FLAG(cur_iterator->flags,
+					 BGP_PATH_MULTIPATH);
+
+			if (!old_mpath)
+				mpath_changed = true;
+
+			if (ecommunity_linkbw_present(
+				    bgp_attr_get_ecommunity(cur_iterator->attr),
+				    &bwval) ||
+			    ecommunity_linkbw_present(
+				    bgp_attr_get_ipv6_ecommunity(
+					    cur_iterator->attr),
+				    &bwval))
+				cum_bw += bwval;
+			else
+				all_paths_lb = false;
+
 			if (debug) {
 				bgp_path_info_path_with_addpath_rx_str(
-					cur_mpath, path_buf, sizeof(path_buf));
+					cur_iterator, path_buf,
+					sizeof(path_buf));
 				zlog_debug(
-					"%pRN: remove mpath %s nexthop %pI4, cur count %d",
-					bgp_dest_to_rnode(dest), path_buf,
-					&cur_mpath->attr->nexthop, mpath_count);
+					"%pBD: add mpath %s nexthop %pI4, cur count %d cum_bw: %" PRIu64
+					" all_paths_lb: %u",
+					dest, path_buf,
+					&cur_iterator->attr->nexthop,
+					mpath_count, cum_bw, all_paths_lb);
 			}
-			cur_mpath = next_mpath;
 		} else {
 			/*
-			 * If here, we have a path on the mp_list that was not
-			 * previously
-			 * a multipath (due to non-equivalance or maxpaths
-			 * exceeded),
-			 * or the matching multipath is sorted later in the
-			 * multipath
-			 * list. Before we enqueue the path on the new multipath
-			 * list,
-			 * make sure its not on the old_best multipath list or
-			 * referenced
-			 * via next_mpath:
-			 * - If next_mpath points to this new path, update
-			 * next_mpath to
-			 *   point to the multipath after this one
-			 * - Dequeue the path from the multipath list just to
-			 * make sure
+			 * We know that old_mpath is true and new_mpath is false
+			 * in this path
 			 */
-			new_mpath = listgetdata(mp_node);
-			list_delete_node(mp_list, mp_node);
-			assert(new_mpath);
-			assert(prev_mpath);
-			if ((mpath_count < maxpaths) && (new_mpath != new_best)
-			    && bgp_path_info_nexthop_cmp(prev_mpath,
-							 new_mpath)) {
-				bgp_path_info_mpath_dequeue(new_mpath);
-
-				bgp_path_info_mpath_enqueue(prev_mpath,
-							    new_mpath);
-				prev_mpath = new_mpath;
-				mpath_changed = 1;
-				mpath_count++;
-				if (ecommunity_linkbw_present(
-					    bgp_attr_get_ecommunity(
-						    new_mpath->attr),
-					    &bwval))
-					cum_bw += bwval;
-				else
-					all_paths_lb = false;
-				if (debug) {
-					bgp_path_info_path_with_addpath_rx_str(
-						new_mpath, path_buf,
-						sizeof(path_buf));
-					zlog_debug(
-						"%pRN: add mpath %s nexthop %pI4, cur count %d",
-						bgp_dest_to_rnode(dest),
-						path_buf,
-						&new_mpath->attr->nexthop,
-						mpath_count);
-				}
-			}
-			mp_node = mp_next_node;
+			mpath_changed = true;
+			UNSET_FLAG(cur_iterator->flags, BGP_PATH_MULTIPATH);
 		}
+
+		cur_iterator = cur_iterator->next;
 	}
 
 	if (new_best) {
-		bgp_path_info_mpath_count_set(new_best, mpath_count - 1);
-		if (mpath_count <= 1 ||
-		    !ecommunity_linkbw_present(
-			    bgp_attr_get_ecommunity(new_best->attr), &bwval))
-			all_paths_lb = false;
-		else
-			cum_bw += bwval;
-		bgp_path_info_mpath_lb_update(new_best, true,
-					      all_paths_lb, cum_bw);
-
+		if (mpath_count > 1 || new_best->mpath) {
+			bgp_path_info_mpath_count_set(new_best, mpath_count);
+			bgp_path_info_mpath_lb_update(new_best, true,
+						      all_paths_lb, cum_bw);
+		}
 		if (debug)
 			zlog_debug(
 				"%pRN(%s): New mpath count (incl newbest) %d mpath-change %s all_paths_lb %d cum_bw %" PRIu64,
@@ -755,11 +587,12 @@ void bgp_path_info_mpath_update(struct bgp *bgp, struct bgp_dest *dest,
 				mpath_count, mpath_changed ? "YES" : "NO",
 				all_paths_lb, cum_bw);
 
+		if (mpath_count == 1)
+			UNSET_FLAG(new_best->flags, BGP_PATH_MULTIPATH);
 		if (mpath_changed
 		    || (bgp_path_info_mpath_count(new_best) != old_mpath_count))
 			SET_FLAG(new_best->flags, BGP_PATH_MULTIPATH_CHG);
-		if ((mpath_count - 1) != old_mpath_count ||
-		    old_cum_bw != cum_bw)
+		if ((mpath_count) != old_mpath_count || old_cum_bw != cum_bw)
 			SET_FLAG(new_best->flags, BGP_PATH_LINK_BW_CHG);
 	}
 }
@@ -772,20 +605,13 @@ void bgp_path_info_mpath_update(struct bgp *bgp, struct bgp_dest *dest,
  */
 void bgp_mp_dmed_deselect(struct bgp_path_info *dmed_best)
 {
-	struct bgp_path_info *mpinfo, *mpnext;
-
 	if (!dmed_best)
 		return;
 
-	for (mpinfo = bgp_path_info_mpath_first(dmed_best); mpinfo;
-	     mpinfo = mpnext) {
-		mpnext = bgp_path_info_mpath_next(mpinfo);
-		bgp_path_info_mpath_dequeue(mpinfo);
-	}
-
 	bgp_path_info_mpath_count_set(dmed_best, 0);
 	UNSET_FLAG(dmed_best->flags, BGP_PATH_MULTIPATH_CHG);
 	UNSET_FLAG(dmed_best->flags, BGP_PATH_LINK_BW_CHG);
+
 	assert(bgp_path_info_mpath_first(dmed_best) == NULL);
 }
 
@@ -823,7 +649,7 @@ void bgp_path_info_mpath_aggregate_update(struct bgp_path_info *new_best,
 	if (!new_best)
 		return;
 
-	if (!bgp_path_info_mpath_count(new_best)) {
+	if (bgp_path_info_mpath_count(new_best) == 1) {
 		if ((new_attr = bgp_path_info_mpath_attr(new_best))) {
 			bgp_attr_unintern(&new_attr);
 			bgp_path_info_mpath_attr_set(new_best, NULL);
diff --git a/bgpd/bgp_mpath.h b/bgpd/bgp_mpath.h
index 4925f16dc1..5f61d0e110 100644
--- a/bgpd/bgp_mpath.h
+++ b/bgpd/bgp_mpath.h
@@ -1,15 +1,16 @@
 /*
  * BGP Multipath
  * Copyright (C) 2010 Google Inc.
+ *               2024 Nvidia Corporation
  *
- * This file is part of Quagga
+ * This file is part of FRR
  *
- * Quagga is free software; you can redistribute it and/or modify it
+ * FRR is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; either version 2, or (at your option) any
  * later version.
  *
- * Quagga is distributed in the hope that it will be useful, but
+ * FRR is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
@@ -26,27 +27,24 @@
  * multipath selections, lazily allocated to save memory
  */
 struct bgp_path_info_mpath {
-	/* Points to the first multipath (on bestpath) or the next multipath */
-	struct bgp_path_info_mpath *mp_next;
-
-	/* Points to the previous multipath or NULL on bestpath */
-	struct bgp_path_info_mpath *mp_prev;
-
 	/* Points to bgp_path_info associated with this multipath info */
 	struct bgp_path_info *mp_info;
 
 	/* When attached to best path, the number of selected multipaths */
 	uint16_t mp_count;
 
-	/* Flags - relevant as noted. */
+	/* Flags - relevant as noted, attached to bestpath. */
 	uint16_t mp_flags;
 #define BGP_MP_LB_PRESENT 0x1 /* Link-bandwidth present for >= 1 path */
 #define BGP_MP_LB_ALL 0x2 /* Link-bandwidth present for all multipaths */
 
-	/* Aggregated attribute for advertising multipath route */
+	/*
+	 * Aggregated attribute for advertising multipath route,
+	 * attached to bestpath
+	 */
 	struct attr *mp_attr;
 
-	/* Cumulative bandiwdth of all multipaths - attached to best path. */
+	/* Cumulative bandiwdth of all multipaths - attached to bestpath. */
 	uint64_t cum_bw;
 };
 
@@ -62,21 +60,17 @@ extern int bgp_maximum_paths_unset(struct bgp *bgp, afi_t afi, safi_t safi,
  */
 extern int bgp_path_info_nexthop_cmp(struct bgp_path_info *bpi1,
 				     struct bgp_path_info *bpi2);
-extern void bgp_mp_list_init(struct list *mp_list);
-extern void bgp_mp_list_clear(struct list *mp_list);
-extern void bgp_mp_list_add(struct list *mp_list, struct bgp_path_info *mpinfo);
 extern void bgp_mp_dmed_deselect(struct bgp_path_info *dmed_best);
 extern void bgp_path_info_mpath_update(struct bgp *bgp, struct bgp_dest *dest,
 				       struct bgp_path_info *new_best,
 				       struct bgp_path_info *old_best,
-				       struct list *mp_list,
+				       uint32_t num_candidates,
 				       struct bgp_maxpaths_cfg *mpath_cfg);
 extern void
 bgp_path_info_mpath_aggregate_update(struct bgp_path_info *new_best,
 				     struct bgp_path_info *old_best);
 
 /* Unlink and free multipath information associated with a bgp_path_info */
-extern void bgp_path_info_mpath_dequeue(struct bgp_path_info *path);
 extern void bgp_path_info_mpath_free(struct bgp_path_info_mpath **mpath);
 
 /* Walk list of multipaths associated with a best path */
diff --git a/bgpd/bgp_mplsvpn.c b/bgpd/bgp_mplsvpn.c
index 2af553d982..9ab3987cd2 100644
--- a/bgpd/bgp_mplsvpn.c
+++ b/bgpd/bgp_mplsvpn.c
@@ -1261,7 +1261,7 @@ leak_update(struct bgp *to_bgp, struct bgp_dest *bn,
 
 		/* Process change. */
 		bgp_aggregate_increment(to_bgp, p, bpi, afi, safi);
-		bgp_process(to_bgp, bn, afi, safi);
+		bgp_process(to_bgp, bn, bpi, afi, safi);
 		bgp_dest_unlock_node(bn);
 
 		if (debug)
@@ -1342,7 +1342,7 @@ leak_update(struct bgp *to_bgp, struct bgp_dest *bn,
 	bgp_path_info_add(bn, new);
 
 	bgp_dest_unlock_node(bn);
-	bgp_process(to_bgp, bn, afi, safi);
+	bgp_process(to_bgp, bn, new, afi, safi);
 
 	if (debug)
 		zlog_debug("%s: ->%s: %pBD: Added new route", __func__,
@@ -1726,7 +1726,7 @@ void vpn_leak_from_vrf_withdraw(struct bgp *to_bgp,		/* to */
 
 		bgp_aggregate_decrement(to_bgp, p, bpi, afi, safi);
 		bgp_path_info_delete(bn, bpi);
-		bgp_process(to_bgp, bn, afi, safi);
+		bgp_process(to_bgp, bn, bpi, afi, safi);
 	}
 	bgp_dest_unlock_node(bn);
 }
@@ -1746,7 +1746,7 @@ void vpn_leak_from_vrf_withdraw_all(struct bgp *to_bgp, struct bgp *from_bgp,
 
 		struct bgp_table *table;
 		struct bgp_dest *bn;
-		struct bgp_path_info *bpi;
+		struct bgp_path_info *bpi, *next;
 
 		/* This is the per-RD table of prefixes */
 		table = bgp_dest_get_bgp_table_info(pdest);
@@ -1761,7 +1761,8 @@ void vpn_leak_from_vrf_withdraw_all(struct bgp *to_bgp, struct bgp *from_bgp,
 					   __func__, bn);
 			}
 
-			for (; bpi; bpi = bpi->next) {
+			for (; (bpi != NULL) && (next = bpi->next, 1);
+			     bpi = next) {
 				if (debug)
 					zlog_debug("%s: type %d, sub_type %d",
 						   __func__, bpi->type,
@@ -1782,7 +1783,7 @@ void vpn_leak_from_vrf_withdraw_all(struct bgp *to_bgp, struct bgp *from_bgp,
 						to_bgp, bgp_dest_get_prefix(bn),
 						bpi, afi, safi);
 					bgp_path_info_delete(bn, bpi);
-					bgp_process(to_bgp, bn, afi, safi);
+					bgp_process(to_bgp, bn, bpi, afi, safi);
 				}
 			}
 		}
@@ -2197,7 +2198,7 @@ void vpn_leak_to_vrf_withdraw(struct bgp_path_info *path_vpn)
 					   bpi);
 			bgp_aggregate_decrement(bgp, p, bpi, afi, safi);
 			bgp_path_info_delete(bn, bpi);
-			bgp_process(bgp, bn, afi, safi);
+			bgp_process(bgp, bn, bpi, afi, safi);
 		}
 		bgp_dest_unlock_node(bn);
 	}
@@ -2206,7 +2207,7 @@ void vpn_leak_to_vrf_withdraw(struct bgp_path_info *path_vpn)
 void vpn_leak_to_vrf_withdraw_all(struct bgp *to_bgp, afi_t afi)
 {
 	struct bgp_dest *bn;
-	struct bgp_path_info *bpi;
+	struct bgp_path_info *bpi, *next;
 	safi_t safi = SAFI_UNICAST;
 	int debug = BGP_DEBUG(vpn, VPN_LEAK_TO_VRF);
 
@@ -2217,9 +2218,8 @@ void vpn_leak_to_vrf_withdraw_all(struct bgp *to_bgp, afi_t afi)
 	 */
 	for (bn = bgp_table_top(to_bgp->rib[afi][safi]); bn;
 	     bn = bgp_route_next(bn)) {
-
-		for (bpi = bgp_dest_get_bgp_path_info(bn); bpi;
-		     bpi = bpi->next) {
+		for (bpi = bgp_dest_get_bgp_path_info(bn);
+		     (bpi != NULL) && (next = bpi->next, 1); bpi = next) {
 			if (bpi->extra && bpi->extra->bgp_orig != to_bgp &&
 			    bpi->extra->parent &&
 			    is_pi_family_vpn(bpi->extra->parent)) {
@@ -2229,7 +2229,7 @@ void vpn_leak_to_vrf_withdraw_all(struct bgp *to_bgp, afi_t afi)
 							bgp_dest_get_prefix(bn),
 							bpi, afi, safi);
 				bgp_path_info_delete(bn, bpi);
-				bgp_process(to_bgp, bn, afi, safi);
+				bgp_process(to_bgp, bn, bpi, afi, safi);
 			}
 		}
 	}
diff --git a/bgpd/bgp_nht.c b/bgpd/bgp_nht.c
index 24e47940a2..20ed0b67de 100644
--- a/bgpd/bgp_nht.c
+++ b/bgpd/bgp_nht.c
@@ -1267,7 +1267,7 @@ void evaluate_paths(struct bgp_nexthop_cache *bnc)
 			}
 		}
 
-		bgp_process(bgp_path, dest, afi, safi);
+		bgp_process(bgp_path, dest, path, afi, safi);
 	}
 
 	if (peer) {
diff --git a/bgpd/bgp_route.c b/bgpd/bgp_route.c
index e28069767f..bcb2dfaaa0 100644
--- a/bgpd/bgp_route.c
+++ b/bgpd/bgp_route.c
@@ -122,6 +122,41 @@ static const struct message bgp_pmsi_tnltype_str[] = {
 #define VRFID_NONE_STR "-"
 #define SOFT_RECONFIG_TASK_MAX_PREFIX 25000
 
+static inline char *bgp_route_dump_path_info_flags(struct bgp_path_info *pi,
+						   char *buf, size_t len)
+{
+	uint32_t flags = pi->flags;
+
+	if (flags == 0) {
+		snprintfrr(buf, len, "None ");
+		return buf;
+	}
+
+	snprintfrr(buf, len, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
+		   CHECK_FLAG(flags, BGP_PATH_IGP_CHANGED) ? "IGP Changed " : "",
+		   CHECK_FLAG(flags, BGP_PATH_DAMPED) ? "Damped" : "",
+		   CHECK_FLAG(flags, BGP_PATH_HISTORY) ? "History " : "",
+		   CHECK_FLAG(flags, BGP_PATH_SELECTED) ? "Selected " : "",
+		   CHECK_FLAG(flags, BGP_PATH_VALID) ? "Valid " : "",
+		   CHECK_FLAG(flags, BGP_PATH_ATTR_CHANGED) ? "Attr Changed "
+							    : "",
+		   CHECK_FLAG(flags, BGP_PATH_DMED_CHECK) ? "Dmed Check " : "",
+		   CHECK_FLAG(flags, BGP_PATH_DMED_SELECTED) ? "Dmed Selected "
+							     : "",
+		   CHECK_FLAG(flags, BGP_PATH_STALE) ? "Stale " : "",
+		   CHECK_FLAG(flags, BGP_PATH_REMOVED) ? "Removed " : "",
+		   CHECK_FLAG(flags, BGP_PATH_COUNTED) ? "Counted " : "",
+		   CHECK_FLAG(flags, BGP_PATH_MULTIPATH) ? "Mpath " : "",
+		   CHECK_FLAG(flags, BGP_PATH_MULTIPATH_CHG) ? "Mpath Chg " : "",
+		   CHECK_FLAG(flags, BGP_PATH_RIB_ATTR_CHG) ? "Rib Chg " : "",
+		   CHECK_FLAG(flags, BGP_PATH_ANNC_NH_SELF) ? "NH Self " : "",
+		   CHECK_FLAG(flags, BGP_PATH_LINK_BW_CHG) ? "LinkBW Chg " : "",
+		   CHECK_FLAG(flags, BGP_PATH_ACCEPT_OWN) ? "Accept Own " : "",
+		   CHECK_FLAG(flags, BGP_PATH_UNSORTED) ? "Unsorted " : "");
+
+	return buf;
+}
+
 DEFINE_HOOK(bgp_process,
 	    (struct bgp * bgp, afi_t afi, safi_t safi, struct bgp_dest *bn,
 	     struct peer *peer, bool withdraw),
@@ -404,6 +439,7 @@ void bgp_path_info_add_with_caller(const char *name, struct bgp_dest *dest,
 		top->prev = pi;
 	bgp_dest_set_bgp_path_info(dest, pi);
 
+	SET_FLAG(pi->flags, BGP_PATH_UNSORTED);
 	bgp_path_info_lock(pi);
 	bgp_dest_lock_node(dest);
 	peer_lock(pi->peer); /* bgp_path_info peer reference */
@@ -422,9 +458,23 @@ void bgp_path_info_reap(struct bgp_dest *dest, struct bgp_path_info *pi)
 	else
 		bgp_dest_set_bgp_path_info(dest, pi->next);
 
-	bgp_path_info_mpath_dequeue(pi);
+	pi->next = NULL;
+	pi->prev = NULL;
+
+	hook_call(bgp_snmp_update_stats, dest, pi, false);
 	bgp_path_info_unlock(pi);
+	bgp_dest_unlock_node(dest);
+}
+
+static void bgp_path_info_reap_unsorted(struct bgp_dest *dest,
+					struct bgp_path_info *pi)
+{
+	pi->next = NULL;
+	pi->prev = NULL;
+
 	hook_call(bgp_snmp_update_stats, dest, pi, false);
+	bgp_path_info_unlock(pi);
+
 	bgp_dest_unlock_node(dest);
 }
 
@@ -622,12 +672,18 @@ static int bgp_path_info_cmp(struct bgp *bgp, struct bgp_path_info *new,
 	}
 
 	if (debug) {
+		char buf1[256], buf2[256];
+
 		bpi_ultimate = bgp_get_imported_bpi_ultimate(exist);
 		bgp_path_info_path_with_addpath_rx_str(bpi_ultimate, exist_buf,
 						       sizeof(exist_buf));
-		zlog_debug("%s(%s): Comparing %s flags 0x%x with %s flags 0x%x",
-			   pfx_buf, bgp->name_pretty, new_buf, new->flags,
-			   exist_buf, exist->flags);
+		zlog_debug("%s(%s): Comparing %s flags %s with %s flags %s",
+			   pfx_buf, bgp->name_pretty, new_buf,
+			   bgp_route_dump_path_info_flags(new, buf1,
+							  sizeof(buf1)),
+			   exist_buf,
+			   bgp_route_dump_path_info_flags(exist, buf2,
+							  sizeof(buf2)));
 	}
 
 	newattr = new->attr;
@@ -1998,8 +2054,9 @@ bool subgroup_announce_check(struct bgp_dest *dest, struct bgp_path_info *pi,
 	from = pi->peer;
 	filter = &peer->filter[afi][safi];
 	bgp = SUBGRP_INST(subgrp);
-	piattr = bgp_path_info_mpath_count(pi) ? bgp_path_info_mpath_attr(pi)
-					       : pi->attr;
+	piattr = bgp_path_info_mpath_count(pi) > 1
+			 ? bgp_path_info_mpath_attr(pi)
+			 : pi->attr;
 
 	if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_OUT) &&
 	    peer->pmax_out[afi][safi] != 0 &&
@@ -2633,18 +2690,19 @@ void bgp_best_selection(struct bgp *bgp, struct bgp_dest *dest,
 			struct bgp_path_info_pair *result, afi_t afi,
 			safi_t safi)
 {
-	struct bgp_path_info *new_select;
-	struct bgp_path_info *old_select;
+	struct bgp_path_info *new_select, *look_thru;
+	struct bgp_path_info *old_select, *worse, *first;
 	struct bgp_path_info *pi;
 	struct bgp_path_info *pi1;
 	struct bgp_path_info *pi2;
-	struct bgp_path_info *nextpi = NULL;
-	int paths_eq, do_mpath, debug;
-	struct list mp_list;
+	int paths_eq, do_mpath;
+	bool debug, any_comparisons;
 	char pfx_buf[PREFIX2STR_BUFFER];
 	char path_buf[PATH_ADDPATH_STR_BUFFER];
+	enum bgp_path_selection_reason reason = bgp_path_selection_none;
+	bool unsorted_items = true;
+	uint32_t num_candidates = 0;
 
-	bgp_mp_list_init(&mp_list);
 	do_mpath =
 		(mpath_cfg->maxpaths_ebgp > 1 || mpath_cfg->maxpaths_ibgp > 1);
 
@@ -2653,16 +2711,16 @@ void bgp_best_selection(struct bgp *bgp, struct bgp_dest *dest,
 	if (debug)
 		prefix2str(bgp_dest_get_prefix(dest), pfx_buf, sizeof(pfx_buf));
 
-	dest->reason = bgp_path_selection_none;
 	/* bgp deterministic-med */
 	new_select = NULL;
 	if (CHECK_FLAG(bgp->flags, BGP_FLAG_DETERMINISTIC_MED)) {
-
 		/* Clear BGP_PATH_DMED_SELECTED for all paths */
 		for (pi1 = bgp_dest_get_bgp_path_info(dest); pi1;
-		     pi1 = pi1->next)
+		     pi1 = pi1->next) {
 			bgp_path_info_unset_flag(dest, pi1,
 						 BGP_PATH_DMED_SELECTED);
+			UNSET_FLAG(pi1->flags, BGP_PATH_DMED_CHECK);
+		}
 
 		for (pi1 = bgp_dest_get_bgp_path_info(dest); pi1;
 		     pi1 = pi1->next) {
@@ -2732,62 +2790,275 @@ void bgp_best_selection(struct bgp *bgp, struct bgp_dest *dest,
 		}
 	}
 
-	/* Check old selected route and new selected route. */
+	/*
+	 * Let's grab the unsorted items from the list
+	 */
+	struct bgp_path_info *unsorted_list = NULL;
+	struct bgp_path_info *unsorted_list_spot = NULL;
+	struct bgp_path_info *unsorted_holddown = NULL;
+
 	old_select = NULL;
-	new_select = NULL;
-	for (pi = bgp_dest_get_bgp_path_info(dest);
-	     (pi != NULL) && (nextpi = pi->next, 1); pi = nextpi) {
-		enum bgp_path_selection_reason reason;
+	pi = bgp_dest_get_bgp_path_info(dest);
+	while (pi && CHECK_FLAG(pi->flags, BGP_PATH_UNSORTED)) {
+		struct bgp_path_info *next = pi->next;
 
 		if (CHECK_FLAG(pi->flags, BGP_PATH_SELECTED))
 			old_select = pi;
 
-		if (BGP_PATH_HOLDDOWN(pi)) {
-			/* reap REMOVED routes, if needs be
+		/*
+		 * Pull off pi off the list
+		 */
+		if (pi->next)
+			pi->next->prev = NULL;
+
+		bgp_dest_set_bgp_path_info(dest, pi->next);
+		pi->next = NULL;
+		pi->prev = NULL;
+
+		/*
+		 * Place it on the unsorted list
+		 */
+		if (unsorted_list_spot) {
+			unsorted_list_spot->next = pi;
+			pi->prev = unsorted_list_spot;
+			pi->next = NULL;
+		} else {
+			unsorted_list = pi;
+
+			pi->next = NULL;
+			pi->prev = NULL;
+		}
+
+		unsorted_list_spot = pi;
+		pi = next;
+	}
+
+	if (!old_select) {
+		old_select = bgp_dest_get_bgp_path_info(dest);
+		if (old_select &&
+		    !CHECK_FLAG(old_select->flags, BGP_PATH_SELECTED))
+			old_select = NULL;
+	}
+
+	if (!unsorted_list)
+		unsorted_items = true;
+	else
+		unsorted_items = false;
+
+	any_comparisons = false;
+	worse = NULL;
+	while (unsorted_list) {
+		first = unsorted_list;
+		unsorted_list = unsorted_list->next;
+
+		if (unsorted_list)
+			unsorted_list->prev = NULL;
+		first->next = NULL;
+		first->prev = NULL;
+
+		/*
+		 * It's not likely that the just received unsorted entry
+		 * is in holddown and scheduled for removal but we should
+		 * check
+		 */
+		if (BGP_PATH_HOLDDOWN(first)) {
+			/*
+			 * reap REMOVED routes, if needs be
 			 * selected route must stay for a while longer though
 			 */
-			if (CHECK_FLAG(pi->flags, BGP_PATH_REMOVED)
-			    && (pi != old_select))
-				bgp_path_info_reap(dest, pi);
-
 			if (debug)
-				zlog_debug("%s: pi %p in holddown", __func__,
-					   pi);
+				zlog_debug(
+					"%s: %pBD(%s) pi %p from %s in holddown",
+					__func__, dest, bgp->name_pretty, first,
+					first->peer->host);
+
+			if (old_select != first &&
+			    CHECK_FLAG(first->flags, BGP_PATH_REMOVED)) {
+				bgp_path_info_reap_unsorted(dest, first);
+			} else {
+				/*
+				 * We are in hold down, so we cannot sort this
+				 * item yet.  Let's wait, so hold the unsorted
+				 * to the side
+				 */
+				if (unsorted_holddown) {
+					first->next = unsorted_holddown;
+					unsorted_holddown->prev = first;
+					unsorted_holddown = first;
+				} else
+					unsorted_holddown = first;
 
+				UNSET_FLAG(first->flags, BGP_PATH_UNSORTED);
+			}
 			continue;
 		}
 
-		if (pi->peer && pi->peer != bgp->peer_self
-		    && !CHECK_FLAG(pi->peer->sflags, PEER_STATUS_NSF_WAIT))
-			if (!peer_established(pi->peer)) {
+		bgp_path_info_unset_flag(dest, first, BGP_PATH_DMED_CHECK);
+
+		worse = NULL;
 
+		struct bgp_path_info *look_thru_next;
+
+		for (look_thru = bgp_dest_get_bgp_path_info(dest); look_thru;
+		     look_thru = look_thru_next) {
+			/* look thru can be reaped save the next pointer */
+			look_thru_next = look_thru->next;
+
+			/*
+			 * Now we have the first unsorted and the best selected
+			 * Let's do best path comparison
+			 */
+			if (BGP_PATH_HOLDDOWN(look_thru)) {
+				/* reap REMOVED routes, if needs be
+				 * selected route must stay for a while longer
+				 * though
+				 */
 				if (debug)
 					zlog_debug(
-						"%s: pi %p non self peer %s not estab state",
-						__func__, pi, pi->peer->host);
+						"%s: %pBD(%s) pi from %s %p in holddown",
+						__func__, dest,
+						bgp->name_pretty,
+						look_thru->peer->host,
+						look_thru);
+
+				if (CHECK_FLAG(look_thru->flags,
+					       BGP_PATH_REMOVED) &&
+				    (look_thru != old_select)) {
+					bgp_path_info_reap(dest, look_thru);
+				}
 
 				continue;
 			}
 
-		if (CHECK_FLAG(bgp->flags, BGP_FLAG_DETERMINISTIC_MED)
-		    && (!CHECK_FLAG(pi->flags, BGP_PATH_DMED_SELECTED))) {
-			bgp_path_info_unset_flag(dest, pi, BGP_PATH_DMED_CHECK);
-			if (debug)
-				zlog_debug("%s: pi %p dmed", __func__, pi);
-			continue;
+			if (look_thru->peer &&
+			    look_thru->peer != bgp->peer_self &&
+			    !CHECK_FLAG(look_thru->peer->sflags,
+					PEER_STATUS_NSF_WAIT))
+				if (!peer_established(look_thru->peer)) {
+					if (debug)
+						zlog_debug(
+							"%s: %pBD(%s) non self peer %s not estab state",
+							__func__, dest,
+							bgp->name_pretty,
+							look_thru->peer->host);
+
+					continue;
+				}
+
+			bgp_path_info_unset_flag(dest, look_thru,
+						 BGP_PATH_DMED_CHECK);
+			if (CHECK_FLAG(bgp->flags,
+				       BGP_FLAG_DETERMINISTIC_MED) &&
+			    (!CHECK_FLAG(look_thru->flags,
+					 BGP_PATH_DMED_SELECTED))) {
+				bgp_path_info_unset_flag(dest, look_thru,
+							 BGP_PATH_DMED_CHECK);
+				if (debug)
+					zlog_debug("%s: %pBD(%s) pi %s dmed",
+						   __func__, dest,
+						   bgp->name_pretty,
+						   look_thru->peer->host);
+
+				worse = look_thru;
+				continue;
+			}
+
+			reason = dest->reason;
+			any_comparisons = true;
+			if (bgp_path_info_cmp(bgp, first, look_thru, &paths_eq,
+					      mpath_cfg, debug, pfx_buf, afi,
+					      safi, &reason)) {
+				first->reason = reason;
+				worse = look_thru;
+				/*
+				 * We can stop looking
+				 */
+				break;
+			}
+
+			look_thru->reason = reason;
 		}
 
-		bgp_path_info_unset_flag(dest, pi, BGP_PATH_DMED_CHECK);
+		if (!any_comparisons)
+			first->reason = bgp_path_selection_first;
+
+		/*
+		 * At this point worse if NON-NULL is where the first
+		 * pointer should be before.  if worse is NULL then
+		 * first is bestpath too.  Let's remove first from the
+		 * list and place it in the right spot
+		 */
+
+		if (!worse) {
+			struct bgp_path_info *end =
+				bgp_dest_get_bgp_path_info(dest);
+
+			for (; end && end->next != NULL; end = end->next)
+				;
 
-		reason = dest->reason;
-		if (bgp_path_info_cmp(bgp, pi, new_select, &paths_eq, mpath_cfg,
-				      debug, pfx_buf, afi, safi,
-				      &dest->reason)) {
-			if (new_select == NULL &&
-			    reason != bgp_path_selection_none)
-				dest->reason = reason;
-			new_select = pi;
+			if (end)
+				end->next = first;
+			else
+				bgp_dest_set_bgp_path_info(dest, first);
+			first->prev = end;
+			first->next = NULL;
+
+			dest->reason = first->reason;
+		} else {
+			if (worse->prev)
+				worse->prev->next = first;
+			first->next = worse;
+			if (worse) {
+				first->prev = worse->prev;
+				worse->prev = first;
+			} else
+				first->prev = NULL;
+
+			if (dest->info == worse) {
+				bgp_dest_set_bgp_path_info(dest, first);
+				dest->reason = first->reason;
+			}
 		}
+		UNSET_FLAG(first->flags, BGP_PATH_UNSORTED);
+	}
+
+	if (!unsorted_items) {
+		new_select = bgp_dest_get_bgp_path_info(dest);
+		while (new_select && BGP_PATH_HOLDDOWN(new_select))
+			new_select = new_select->next;
+
+		if (new_select) {
+			if (new_select->reason == bgp_path_selection_none)
+				new_select->reason = bgp_path_selection_first;
+			else if (new_select ==
+					 bgp_dest_get_bgp_path_info(dest) &&
+				 new_select->next == NULL)
+				new_select->reason = bgp_path_selection_first;
+			dest->reason = new_select->reason;
+		} else
+			dest->reason = bgp_path_selection_none;
+	} else
+		new_select = old_select;
+
+
+	/*
+	 * Reinsert all the unsorted_holddown items for future processing
+	 * at the end of the list.
+	 */
+	if (unsorted_holddown) {
+		struct bgp_path_info *top = bgp_dest_get_bgp_path_info(dest);
+		struct bgp_path_info *prev = NULL;
+
+		while (top != NULL) {
+			prev = top;
+			top = top->next;
+		}
+
+		if (prev) {
+			prev->next = unsorted_holddown;
+			unsorted_holddown->prev = prev;
+		} else
+			bgp_dest_set_bgp_path_info(dest, unsorted_holddown);
 	}
 
 	/* Now that we know which path is the bestpath see if any of the other
@@ -2807,9 +3078,7 @@ void bgp_best_selection(struct bgp *bgp, struct bgp_dest *dest,
 	}
 
 	if (do_mpath && new_select) {
-		for (pi = bgp_dest_get_bgp_path_info(dest);
-		     (pi != NULL) && (nextpi = pi->next, 1); pi = nextpi) {
-
+		for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next) {
 			if (debug)
 				bgp_path_info_path_with_addpath_rx_str(
 					pi, path_buf, sizeof(path_buf));
@@ -2820,7 +3089,8 @@ void bgp_best_selection(struct bgp *bgp, struct bgp_dest *dest,
 						"%pBD(%s): %s is the bestpath, add to the multipath list",
 						dest, bgp->name_pretty,
 						path_buf);
-				bgp_mp_list_add(&mp_list, pi);
+				SET_FLAG(pi->flags, BGP_PATH_MULTIPATH_NEW);
+				num_candidates++;
 				continue;
 			}
 
@@ -2848,17 +3118,18 @@ void bgp_best_selection(struct bgp *bgp, struct bgp_dest *dest,
 			if (paths_eq) {
 				if (debug)
 					zlog_debug(
-						"%pBD: %s is equivalent to the bestpath, add to the multipath list",
-						dest, path_buf);
-				bgp_mp_list_add(&mp_list, pi);
+						"%pBD(%s): %s is equivalent to the bestpath, add to the multipath list",
+						dest, bgp->name_pretty,
+						path_buf);
+				SET_FLAG(pi->flags, BGP_PATH_MULTIPATH_NEW);
+				num_candidates++;
 			}
 		}
 	}
 
-	bgp_path_info_mpath_update(bgp, dest, new_select, old_select, &mp_list,
-				   mpath_cfg);
+	bgp_path_info_mpath_update(bgp, dest, new_select, old_select,
+				   num_candidates, mpath_cfg);
 	bgp_path_info_mpath_aggregate_update(new_select, old_select);
-	bgp_mp_list_clear(&mp_list);
 
 	bgp_addpath_update_ids(bgp, dest, afi, safi);
 
@@ -3272,7 +3543,8 @@ static void bgp_process_main_one(struct bgp *bgp, struct bgp_dest *dest,
 		bgp_path_info_unset_flag(dest, old_select, BGP_PATH_SELECTED);
 	if (new_select) {
 		if (debug)
-			zlog_debug("%s: setting SELECTED flag", __func__);
+			zlog_debug("%s: %pBD setting SELECTED flag", __func__,
+				   dest);
 		bgp_path_info_set_flag(dest, new_select, BGP_PATH_SELECTED);
 		bgp_path_info_unset_flag(dest, new_select,
 					 BGP_PATH_ATTR_CHANGED);
@@ -3486,13 +3758,38 @@ static struct bgp_process_queue *bgp_processq_alloc(struct bgp *bgp)
 	return pqnode;
 }
 
-void bgp_process(struct bgp *bgp, struct bgp_dest *dest, afi_t afi, safi_t safi)
+void bgp_process(struct bgp *bgp, struct bgp_dest *dest,
+		 struct bgp_path_info *pi, afi_t afi, safi_t safi)
 {
 #define ARBITRARY_PROCESS_QLEN		10000
 	struct work_queue *wq = bgp->process_queue;
 	struct bgp_process_queue *pqnode;
 	int pqnode_reuse = 0;
 
+	/*
+	 * Indicate that *this* pi is in an unsorted
+	 * situation, even if the node is already
+	 * scheduled.
+	 */
+	if (pi) {
+		struct bgp_path_info *first = bgp_dest_get_bgp_path_info(dest);
+
+		SET_FLAG(pi->flags, BGP_PATH_UNSORTED);
+
+		if (pi != first) {
+			if (pi->next)
+				pi->next->prev = pi->prev;
+			if (pi->prev)
+				pi->prev->next = pi->next;
+
+			if (first)
+				first->prev = pi;
+			pi->next = first;
+			pi->prev = NULL;
+			bgp_dest_set_bgp_path_info(dest, pi);
+		}
+	}
+
 	/* already scheduled for processing? */
 	if (CHECK_FLAG(dest->flags, BGP_NODE_PROCESS_SCHEDULED))
 		return;
@@ -3742,7 +4039,7 @@ void bgp_rib_remove(struct bgp_dest *dest, struct bgp_path_info *pi,
 	}
 
 	hook_call(bgp_process, peer->bgp, afi, safi, dest, peer, true);
-	bgp_process(peer->bgp, dest, afi, safi);
+	bgp_process(peer->bgp, dest, pi, afi, safi);
 }
 
 static void bgp_rib_withdraw(struct bgp_dest *dest, struct bgp_path_info *pi,
@@ -4321,7 +4618,7 @@ void bgp_update(struct peer *peer, const struct prefix *p, uint32_t addpath_id,
 				    != BGP_DAMP_SUPPRESSED) {
 					bgp_aggregate_increment(bgp, p, pi, afi,
 								safi);
-					bgp_process(bgp, dest, afi, safi);
+					bgp_process(bgp, dest, pi, afi, safi);
 				}
 			} else /* Duplicate - odd */
 			{
@@ -4349,7 +4646,7 @@ void bgp_update(struct peer *peer, const struct prefix *p, uint32_t addpath_id,
 					bgp_path_info_unset_flag(
 						dest, pi, BGP_PATH_STALE);
 					bgp_dest_set_defer_flag(dest, false);
-					bgp_process(bgp, dest, afi, safi);
+					bgp_process(bgp, dest, pi, afi, safi);
 				}
 			}
 
@@ -4656,7 +4953,7 @@ void bgp_update(struct peer *peer, const struct prefix *p, uint32_t addpath_id,
 		/* Process change. */
 		bgp_aggregate_increment(bgp, p, pi, afi, safi);
 
-		bgp_process(bgp, dest, afi, safi);
+		bgp_process(bgp, dest, pi, afi, safi);
 		bgp_dest_unlock_node(dest);
 
 		if (SAFI_UNICAST == safi
@@ -4821,7 +5118,7 @@ void bgp_update(struct peer *peer, const struct prefix *p, uint32_t addpath_id,
 	hook_call(bgp_process, bgp, afi, safi, dest, peer, false);
 
 	/* Process change. */
-	bgp_process(bgp, dest, afi, safi);
+	bgp_process(bgp, dest, new, afi, safi);
 
 	if (SAFI_UNICAST == safi
 	    && (bgp->inst_type == BGP_INSTANCE_TYPE_VRF
@@ -5398,7 +5695,7 @@ static wq_item_status bgp_clear_route_node(struct work_queue *wq, void *data)
 	struct bgp_clear_node_queue *cnq = data;
 	struct bgp_dest *dest = cnq->dest;
 	struct peer *peer = wq->spec.data;
-	struct bgp_path_info *pi;
+	struct bgp_path_info *pi, *next;
 	struct bgp *bgp;
 	afi_t afi = bgp_dest_table(dest)->afi;
 	safi_t safi = bgp_dest_table(dest)->safi;
@@ -5409,7 +5706,8 @@ static wq_item_status bgp_clear_route_node(struct work_queue *wq, void *data)
 	/* It is possible that we have multiple paths for a prefix from a peer
 	 * if that peer is using AddPath.
 	 */
-	for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next) {
+	for (pi = bgp_dest_get_bgp_path_info(dest);
+	     (pi != NULL) && (next = pi->next, 1); pi = next) {
 		if (pi->peer != peer)
 			continue;
 
@@ -5666,7 +5964,7 @@ void bgp_clear_adj_in(struct peer *peer, afi_t afi, safi_t safi)
 void bgp_clear_stale_route(struct peer *peer, afi_t afi, safi_t safi)
 {
 	struct bgp_dest *dest;
-	struct bgp_path_info *pi;
+	struct bgp_path_info *pi, *next;
 	struct bgp_table *table;
 
 	if (safi == SAFI_MPLS_VPN || safi == SAFI_ENCAP || safi == SAFI_EVPN) {
@@ -5681,8 +5979,9 @@ void bgp_clear_stale_route(struct peer *peer, afi_t afi, safi_t safi)
 
 			for (rm = bgp_table_top(table); rm;
 			     rm = bgp_route_next(rm))
-				for (pi = bgp_dest_get_bgp_path_info(rm); pi;
-				     pi = pi->next) {
+				for (pi = bgp_dest_get_bgp_path_info(rm);
+				     (pi != NULL) && (next = pi->next, 1);
+				     pi = next) {
 					if (pi->peer != peer)
 						continue;
 					if (CHECK_FLAG(
@@ -5715,8 +6014,8 @@ void bgp_clear_stale_route(struct peer *peer, afi_t afi, safi_t safi)
 	} else {
 		for (dest = bgp_table_top(peer->bgp->rib[afi][safi]); dest;
 		     dest = bgp_route_next(dest))
-			for (pi = bgp_dest_get_bgp_path_info(dest); pi;
-			     pi = pi->next) {
+			for (pi = bgp_dest_get_bgp_path_info(dest);
+			     (pi != NULL) && (next = pi->next, 1); pi = next) {
 				if (pi->peer != peer)
 					continue;
 				if (CHECK_FLAG(peer->af_sflags[afi][safi],
@@ -6275,7 +6574,7 @@ void bgp_static_update(struct bgp *bgp, const struct prefix *p,
 			}
 			/* Process change. */
 			bgp_aggregate_increment(bgp, p, pi, afi, safi);
-			bgp_process(bgp, dest, afi, safi);
+			bgp_process(bgp, dest, pi, afi, safi);
 
 			if (SAFI_UNICAST == safi
 			    && (bgp->inst_type == BGP_INSTANCE_TYPE_VRF
@@ -6332,7 +6631,7 @@ void bgp_static_update(struct bgp *bgp, const struct prefix *p,
 	bgp_dest_unlock_node(dest);
 
 	/* Process change. */
-	bgp_process(bgp, dest, afi, safi);
+	bgp_process(bgp, dest, new, afi, safi);
 
 	if (SAFI_UNICAST == safi
 	    && (bgp->inst_type == BGP_INSTANCE_TYPE_VRF
@@ -6368,7 +6667,7 @@ void bgp_static_withdraw(struct bgp *bgp, const struct prefix *p, afi_t afi,
 		bgp_aggregate_decrement(bgp, p, pi, afi, safi);
 		bgp_unlink_nexthop(pi);
 		bgp_path_info_delete(dest, pi);
-		bgp_process(bgp, dest, afi, safi);
+		bgp_process(bgp, dest, pi, afi, safi);
 	}
 
 	/* Unlock bgp_node_lookup. */
@@ -6395,6 +6694,7 @@ static void bgp_static_withdraw_safi(struct bgp *bgp, const struct prefix *p,
 
 	/* Withdraw static BGP route from routing table. */
 	if (pi) {
+		SET_FLAG(pi->flags, BGP_PATH_UNSORTED);
 #ifdef ENABLE_BGP_VNC
 		rfapiProcessWithdraw(
 			pi->peer, NULL, p, prd, pi->attr, afi, safi, pi->type,
@@ -6406,7 +6706,7 @@ static void bgp_static_withdraw_safi(struct bgp *bgp, const struct prefix *p,
 		}
 		bgp_aggregate_decrement(bgp, p, pi, afi, safi);
 		bgp_path_info_delete(dest, pi);
-		bgp_process(bgp, dest, afi, safi);
+		bgp_process(bgp, dest, pi, afi, safi);
 	}
 
 	/* Unlock bgp_node_lookup. */
@@ -6533,7 +6833,7 @@ static void bgp_static_update_safi(struct bgp *bgp, const struct prefix *p,
 
 			/* Process change. */
 			bgp_aggregate_increment(bgp, p, pi, afi, safi);
-			bgp_process(bgp, dest, afi, safi);
+			bgp_process(bgp, dest, pi, afi, safi);
 
 			if (SAFI_MPLS_VPN == safi
 			    && bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT) {
@@ -6574,7 +6874,7 @@ static void bgp_static_update_safi(struct bgp *bgp, const struct prefix *p,
 	bgp_dest_unlock_node(dest);
 
 	/* Process change. */
-	bgp_process(bgp, dest, afi, safi);
+	bgp_process(bgp, dest, new, afi, safi);
 
 	if (SAFI_MPLS_VPN == safi
 	    && bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT) {
@@ -6888,7 +7188,7 @@ static void bgp_purge_af_static_redist_routes(struct bgp *bgp, afi_t afi,
 					safi);
 				bgp_unlink_nexthop(pi);
 				bgp_path_info_delete(dest, pi);
-				bgp_process(bgp, dest, afi, safi);
+				bgp_process(bgp, dest, pi, afi, safi);
 			}
 		}
 	}
@@ -7439,8 +7739,10 @@ static void bgp_aggregate_install(
 		/*
 		 * Mark the old as unusable
 		 */
-		if (pi)
+		if (pi) {
 			bgp_path_info_delete(dest, pi);
+			bgp_process(bgp, dest, pi, afi, safi);
+		}
 
 		attr = bgp_attr_aggregate_intern(
 			bgp, origin, aspath, community, ecommunity, lcommunity,
@@ -7461,7 +7763,7 @@ static void bgp_aggregate_install(
 		SET_FLAG(new->flags, BGP_PATH_VALID);
 
 		bgp_path_info_add(dest, new);
-		bgp_process(bgp, dest, afi, safi);
+		bgp_process(bgp, dest, new, afi, safi);
 	} else {
 	uninstall_aggregate_route:
 		for (pi = orig; pi; pi = pi->next)
@@ -7473,7 +7775,7 @@ static void bgp_aggregate_install(
 		/* Withdraw static BGP route from routing table. */
 		if (pi) {
 			bgp_path_info_delete(dest, pi);
-			bgp_process(bgp, dest, afi, safi);
+			bgp_process(bgp, dest, pi, afi, safi);
 		}
 	}
 
@@ -7559,7 +7861,6 @@ void bgp_aggregate_toggle_suppressed(struct bgp_aggregate *aggregate,
 	const struct prefix *dest_p;
 	struct bgp_dest *dest, *top;
 	struct bgp_path_info *pi;
-	bool toggle_suppression;
 
 	/* We've found a different MED we must revert any suppressed routes. */
 	top = bgp_node_get(table, p);
@@ -7569,7 +7870,6 @@ void bgp_aggregate_toggle_suppressed(struct bgp_aggregate *aggregate,
 		if (dest_p->prefixlen <= p->prefixlen)
 			continue;
 
-		toggle_suppression = false;
 		for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next) {
 			if (BGP_PATH_HOLDDOWN(pi))
 				continue;
@@ -7580,17 +7880,14 @@ void bgp_aggregate_toggle_suppressed(struct bgp_aggregate *aggregate,
 			if (suppress) {
 				/* Suppress route if not suppressed already. */
 				if (aggr_suppress_path(aggregate, pi))
-					toggle_suppression = true;
+					bgp_process(bgp, dest, pi, afi, safi);
 				continue;
 			}
 
 			/* Install route if there is no more suppression. */
 			if (aggr_unsuppress_path(aggregate, pi))
-				toggle_suppression = true;
+				bgp_process(bgp, dest, pi, afi, safi);
 		}
-
-		if (toggle_suppression)
-			bgp_process(bgp, dest, afi, safi);
 	}
 	bgp_dest_unlock_node(top);
 }
@@ -7649,7 +7946,6 @@ bool bgp_aggregate_route(struct bgp *bgp, const struct prefix *p, afi_t afi,
 	struct ecommunity *ecommunity = NULL;
 	struct lcommunity *lcommunity = NULL;
 	struct bgp_path_info *pi;
-	unsigned long match = 0;
 	uint8_t atomic_aggregate = 0;
 
 	/* If the bgp instance is being deleted or self peer is deleted
@@ -7700,8 +7996,6 @@ bool bgp_aggregate_route(struct bgp *bgp, const struct prefix *p, afi_t afi,
 		if (!bgp_check_advertise(bgp, dest))
 			continue;
 
-		match = 0;
-
 		for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next) {
 			if (BGP_PATH_HOLDDOWN(pi))
 				continue;
@@ -7725,7 +8019,7 @@ bool bgp_aggregate_route(struct bgp *bgp, const struct prefix *p, afi_t afi,
 			if (aggregate->summary_only
 			    && AGGREGATE_MED_VALID(aggregate)) {
 				if (aggr_suppress_path(aggregate, pi))
-					match++;
+					bgp_process(bgp, dest, pi, afi, safi);
 			}
 
 			/*
@@ -7741,7 +8035,7 @@ bool bgp_aggregate_route(struct bgp *bgp, const struct prefix *p, afi_t afi,
 			    && AGGREGATE_MED_VALID(aggregate)
 			    && aggr_suppress_map_test(bgp, aggregate, pi)) {
 				if (aggr_suppress_path(aggregate, pi))
-					match++;
+					bgp_process(bgp, dest, pi, afi, safi);
 			}
 
 			aggregate->count++;
@@ -7802,8 +8096,6 @@ bool bgp_aggregate_route(struct bgp *bgp, const struct prefix *p, afi_t afi,
 					aggregate,
 					bgp_attr_get_lcommunity(pi->attr));
 		}
-		if (match)
-			bgp_process(bgp, dest, afi, safi);
 	}
 	if (aggregate->as_set) {
 		bgp_compute_aggregate_aspath_val(aggregate);
@@ -7860,7 +8152,6 @@ void bgp_aggregate_delete(struct bgp *bgp, const struct prefix *p, afi_t afi,
 	struct bgp_dest *top;
 	struct bgp_dest *dest;
 	struct bgp_path_info *pi;
-	unsigned long match;
 
 	table = bgp->rib[afi][safi];
 
@@ -7872,7 +8163,6 @@ void bgp_aggregate_delete(struct bgp *bgp, const struct prefix *p, afi_t afi,
 
 		if (dest_p->prefixlen <= p->prefixlen)
 			continue;
-		match = 0;
 
 		for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next) {
 			if (BGP_PATH_HOLDDOWN(pi))
@@ -7890,10 +8180,11 @@ void bgp_aggregate_delete(struct bgp *bgp, const struct prefix *p, afi_t afi,
 			if (pi->extra && pi->extra->aggr_suppressors &&
 			    listcount(pi->extra->aggr_suppressors)) {
 				if (aggr_unsuppress_path(aggregate, pi))
-					match++;
+					bgp_process(bgp, dest, pi, afi, safi);
 			}
 
-			aggregate->count--;
+			if (aggregate->count > 0)
+				aggregate->count--;
 
 			if (pi->attr->origin == BGP_ORIGIN_INCOMPLETE)
 				aggregate->incomplete_origin_count--;
@@ -7932,10 +8223,6 @@ void bgp_aggregate_delete(struct bgp *bgp, const struct prefix *p, afi_t afi,
 							pi->attr));
 			}
 		}
-
-		/* If this node was suppressed, process the change. */
-		if (match)
-			bgp_process(bgp, dest, afi, safi);
 	}
 	if (aggregate->as_set) {
 		aspath_free(aggregate->aspath);
@@ -8084,7 +8371,6 @@ static void bgp_remove_route_from_aggregate(struct bgp *bgp, afi_t afi,
 	struct community *community = NULL;
 	struct ecommunity *ecommunity = NULL;
 	struct lcommunity *lcommunity = NULL;
-	unsigned long match = 0;
 
 	/* If the bgp instance is being deleted or self peer is deleted
 	 * then do not create aggregate route
@@ -8101,12 +8387,12 @@ static void bgp_remove_route_from_aggregate(struct bgp *bgp, afi_t afi,
 
 	if (aggregate->summary_only && AGGREGATE_MED_VALID(aggregate))
 		if (aggr_unsuppress_path(aggregate, pi))
-			match++;
+			bgp_process(bgp, pi->net, pi, afi, safi);
 
 	if (aggregate->suppress_map_name && AGGREGATE_MED_VALID(aggregate)
 	    && aggr_suppress_map_test(bgp, aggregate, pi))
 		if (aggr_unsuppress_path(aggregate, pi))
-			match++;
+			bgp_process(bgp, pi->net, pi, afi, safi);
 
 	/*
 	 * This must be called after `summary`, `suppress-map` check to avoid
@@ -8148,10 +8434,6 @@ static void bgp_remove_route_from_aggregate(struct bgp *bgp, afi_t afi,
 				aggregate, bgp_attr_get_lcommunity(pi->attr));
 	}
 
-	/* If this node was suppressed, process the change. */
-	if (match)
-		bgp_process(bgp, pi->net, afi, safi);
-
 	origin = BGP_ORIGIN_IGP;
 	if (aggregate->incomplete_origin_count > 0)
 		origin = BGP_ORIGIN_INCOMPLETE;
@@ -8776,7 +9058,7 @@ void bgp_redistribute_add(struct bgp *bgp, struct prefix *p,
 				/* Process change. */
 				bgp_aggregate_increment(bgp, p, bpi, afi,
 							SAFI_UNICAST);
-				bgp_process(bgp, bn, afi, SAFI_UNICAST);
+				bgp_process(bgp, bn, bpi, afi, SAFI_UNICAST);
 				bgp_dest_unlock_node(bn);
 				aspath_unintern(&attr.aspath);
 
@@ -8799,7 +9081,7 @@ void bgp_redistribute_add(struct bgp *bgp, struct prefix *p,
 		bgp_path_info_add(bn, new);
 		bgp_dest_unlock_node(bn);
 		SET_FLAG(bn->flags, BGP_NODE_FIB_INSTALLED);
-		bgp_process(bgp, bn, afi, SAFI_UNICAST);
+		bgp_process(bgp, bn, new, afi, SAFI_UNICAST);
 
 		if ((bgp->inst_type == BGP_INSTANCE_TYPE_VRF)
 		    || (bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)) {
@@ -8840,7 +9122,7 @@ void bgp_redistribute_delete(struct bgp *bgp, struct prefix *p, uint8_t type,
 			}
 			bgp_aggregate_decrement(bgp, p, pi, afi, SAFI_UNICAST);
 			bgp_path_info_delete(dest, pi);
-			bgp_process(bgp, dest, afi, SAFI_UNICAST);
+			bgp_process(bgp, dest, pi, afi, SAFI_UNICAST);
 		}
 		bgp_dest_unlock_node(dest);
 	}
@@ -8874,7 +9156,7 @@ void bgp_redistribute_withdraw(struct bgp *bgp, afi_t afi, int type,
 			bgp_path_info_delete(dest, pi);
 			if (!CHECK_FLAG(bgp->flags,
 					BGP_FLAG_DELETE_IN_PROGRESS))
-				bgp_process(bgp, dest, afi, SAFI_UNICAST);
+				bgp_process(bgp, dest, pi, afi, SAFI_UNICAST);
 			else
 				bgp_path_info_reap(dest, pi);
 		}
@@ -9018,6 +9300,9 @@ static void route_vty_short_status_out(struct vty *vty,
 		if (path->extra && bgp_path_suppressed(path))
 			json_object_boolean_true_add(json_path, "suppressed");
 
+		if (CHECK_FLAG(path->flags, BGP_PATH_UNSORTED))
+			json_object_boolean_true_add(json_path, "unsorted");
+
 		if (CHECK_FLAG(path->flags, BGP_PATH_VALID)
 		    && !CHECK_FLAG(path->flags, BGP_PATH_HISTORY))
 			json_object_boolean_true_add(json_path, "valid");
@@ -9080,6 +9365,8 @@ static void route_vty_short_status_out(struct vty *vty,
 	/* Selected */
 	if (CHECK_FLAG(path->flags, BGP_PATH_HISTORY))
 		vty_out(vty, "h");
+	else if (CHECK_FLAG(path->flags, BGP_PATH_UNSORTED))
+		vty_out(vty, "u");
 	else if (CHECK_FLAG(path->flags, BGP_PATH_DAMPED))
 		vty_out(vty, "d");
 	else if (CHECK_FLAG(path->flags, BGP_PATH_SELECTED))
@@ -10808,9 +11095,9 @@ void route_vty_out_detail(struct vty *vty, struct bgp *bgp, struct bgp_dest *bn,
 			vty_out(vty, ", otc %u", attr->otc);
 	}
 
-	if (CHECK_FLAG(path->flags, BGP_PATH_MULTIPATH)
-	    || (CHECK_FLAG(path->flags, BGP_PATH_SELECTED)
-		&& bgp_path_info_mpath_count(path))) {
+	if (CHECK_FLAG(path->flags, BGP_PATH_MULTIPATH) ||
+	    (CHECK_FLAG(path->flags, BGP_PATH_SELECTED) &&
+	     bgp_path_info_mpath_count(path) > 1)) {
 		if (json_paths)
 			json_object_boolean_true_add(json_path, "multipath");
 		else
@@ -13636,21 +13923,23 @@ enum bgp_pcounts {
 	PCOUNT_COUNTED,
 	PCOUNT_BPATH_SELECTED,
 	PCOUNT_PFCNT, /* the figure we display to users */
+	PCOUNT_UNSORTED,
 	PCOUNT_MAX,
 };
 
 static const char *const pcount_strs[] = {
-		[PCOUNT_ADJ_IN] = "Adj-in",
-		[PCOUNT_DAMPED] = "Damped",
-		[PCOUNT_REMOVED] = "Removed",
-		[PCOUNT_HISTORY] = "History",
-		[PCOUNT_STALE] = "Stale",
-		[PCOUNT_VALID] = "Valid",
-		[PCOUNT_ALL] = "All RIB",
-		[PCOUNT_COUNTED] = "PfxCt counted",
-		[PCOUNT_BPATH_SELECTED] = "PfxCt Best Selected",
-		[PCOUNT_PFCNT] = "Useable",
-		[PCOUNT_MAX] = NULL,
+	[PCOUNT_ADJ_IN] = "Adj-in",
+	[PCOUNT_DAMPED] = "Damped",
+	[PCOUNT_REMOVED] = "Removed",
+	[PCOUNT_HISTORY] = "History",
+	[PCOUNT_STALE] = "Stale",
+	[PCOUNT_VALID] = "Valid",
+	[PCOUNT_ALL] = "All RIB",
+	[PCOUNT_COUNTED] = "PfxCt counted",
+	[PCOUNT_BPATH_SELECTED] = "PfxCt Best Selected",
+	[PCOUNT_PFCNT] = "Useable",
+	[PCOUNT_UNSORTED] = "Unsorted",
+	[PCOUNT_MAX] = NULL,
 };
 
 struct peer_pcounts {
@@ -13691,6 +13980,8 @@ static void bgp_peer_count_proc(struct bgp_dest *rn, struct peer_pcounts *pc)
 			pc->count[PCOUNT_PFCNT]++;
 		if (CHECK_FLAG(pi->flags, BGP_PATH_SELECTED))
 			pc->count[PCOUNT_BPATH_SELECTED]++;
+		if (CHECK_FLAG(pi->flags, BGP_PATH_UNSORTED))
+			pc->count[PCOUNT_UNSORTED]++;
 
 		if (CHECK_FLAG(pi->flags, BGP_PATH_COUNTED)) {
 			pc->count[PCOUNT_COUNTED]++;
diff --git a/bgpd/bgp_route.h b/bgpd/bgp_route.h
index 5f85336f37..11b8579bdd 100644
--- a/bgpd/bgp_route.h
+++ b/bgpd/bgp_route.h
@@ -73,7 +73,7 @@ enum bgp_show_adj_route_type {
 
 #define BGP_SHOW_SCODE_HEADER                                                  \
 	"Status codes:  s suppressed, d damped, "                              \
-	"h history, * valid, > best, = multipath,\n"                           \
+	"h history, u unsorted, * valid, > best, = multipath,\n"               \
 	"               i internal, r RIB-failure, S Stale, R Removed\n"
 #define BGP_SHOW_OCODE_HEADER                                                  \
 	"Origin codes:  i - IGP, e - EGP, ? - incomplete\n"
@@ -306,12 +306,27 @@ struct bgp_path_info {
 #define BGP_PATH_STALE (1 << 8)
 #define BGP_PATH_REMOVED (1 << 9)
 #define BGP_PATH_COUNTED (1 << 10)
+/*
+ * A BGP_PATH_MULTIPATH flag is not set on the best path
+ * it is set on every other node that is part of ECMP
+ * for that particular dest
+ */
 #define BGP_PATH_MULTIPATH (1 << 11)
 #define BGP_PATH_MULTIPATH_CHG (1 << 12)
 #define BGP_PATH_RIB_ATTR_CHG (1 << 13)
 #define BGP_PATH_ANNC_NH_SELF (1 << 14)
 #define BGP_PATH_LINK_BW_CHG (1 << 15)
 #define BGP_PATH_ACCEPT_OWN (1 << 16)
+#define BGP_PATH_UNSORTED (1 << 19)
+/*
+ * BGP_PATH_MULTIPATH_NEW is set on those bgp_path_info
+ * nodes that we have decided should possibly be in the
+ * ecmp path for a particular dest.  This flag is
+ * removed when the bgp_path_info's are looked at to
+ * decide on whether or not a bgp_path_info is on
+ * the actual ecmp path.
+ */
+#define BGP_PATH_MULTIPATH_NEW (1 << 20)
 
 	/* BGP route type.  This can be static, RIP, OSPF, BGP etc.  */
 	uint8_t type;
@@ -330,6 +345,8 @@ struct bgp_path_info {
 
 	unsigned short instance;
 
+	enum bgp_path_selection_reason reason;
+
 	/* Addpath identifiers */
 	uint32_t addpath_rx_id;
 	struct bgp_addpath_info_data tx_addpath;
@@ -764,7 +781,8 @@ extern void bgp_withdraw(struct peer *peer, const struct prefix *p,
 			 uint32_t num_labels, struct bgp_route_evpn *evpn);
 
 /* for bgp_nexthop and bgp_damp */
-extern void bgp_process(struct bgp *, struct bgp_dest *, afi_t, safi_t);
+extern void bgp_process(struct bgp *bgp, struct bgp_dest *dest,
+			struct bgp_path_info *pi, afi_t afi, safi_t safi);
 
 /*
  * Add an end-of-initial-update marker to the process queue. This is just a
diff --git a/bgpd/bgp_routemap.c b/bgpd/bgp_routemap.c
index 771e48b426..66c5fe34c9 100644
--- a/bgpd/bgp_routemap.c
+++ b/bgpd/bgp_routemap.c
@@ -2876,7 +2876,7 @@ route_set_ecommunity_lb(void *rule, const struct prefix *prefix, void *object)
 			return RMAP_OKAY;
 
 		bw_bytes = ((uint64_t)peer->bgp->lb_ref_bw * 1000 * 1000) / 8;
-		mpath_count = bgp_path_info_mpath_count(path) + 1;
+		mpath_count = bgp_path_info_mpath_count(path);
 		bw_bytes *= mpath_count;
 	}
 
diff --git a/bgpd/bgp_vty.c b/bgpd/bgp_vty.c
index 74bbd51c05..240b892323 100644
--- a/bgpd/bgp_vty.c
+++ b/bgpd/bgp_vty.c
@@ -10059,7 +10059,10 @@ static int bgp_clear_prefix(struct vty *vty, const char *view_name,
 				if (rm_p->prefixlen == match.prefixlen) {
 					SET_FLAG(rm->flags,
 						 BGP_NODE_USER_CLEAR);
-					bgp_process(bgp, rm, afi, safi);
+					bgp_process(
+						bgp, rm,
+						bgp_dest_get_bgp_path_info(rm),
+						afi, safi);
 				}
 				bgp_dest_unlock_node(rm);
 			}
@@ -10071,7 +10074,9 @@ static int bgp_clear_prefix(struct vty *vty, const char *view_name,
 
 			if (dest_p->prefixlen == match.prefixlen) {
 				SET_FLAG(dest->flags, BGP_NODE_USER_CLEAR);
-				bgp_process(bgp, dest, afi, safi);
+				bgp_process(bgp, dest,
+					    bgp_dest_get_bgp_path_info(dest),
+					    afi, safi);
 			}
 			bgp_dest_unlock_node(dest);
 		}
diff --git a/bgpd/bgp_zebra.c b/bgpd/bgp_zebra.c
index 038d328a60..88f0051e47 100644
--- a/bgpd/bgp_zebra.c
+++ b/bgpd/bgp_zebra.c
@@ -2189,7 +2189,7 @@ bool bgp_redistribute_metric_set(struct bgp *bgp, struct bgp_redist *red,
 
 				bgp_path_info_set_flag(dest, pi,
 						       BGP_PATH_ATTR_CHANGED);
-				bgp_process(bgp, dest, afi, SAFI_UNICAST);
+				bgp_process(bgp, dest, pi, afi, SAFI_UNICAST);
 			}
 		}
 	}
diff --git a/bgpd/bgpd.c b/bgpd/bgpd.c
index 342982069b..483fd89f51 100644
--- a/bgpd/bgpd.c
+++ b/bgpd/bgpd.c
@@ -1725,21 +1725,31 @@ void bgp_peer_conf_if_to_su_update(struct peer *peer)
 void bgp_recalculate_afi_safi_bestpaths(struct bgp *bgp, afi_t afi, safi_t safi)
 {
 	struct bgp_dest *dest, *ndest;
+	struct bgp_path_info *pi, *next;
 	struct bgp_table *table;
 
 	for (dest = bgp_table_top(bgp->rib[afi][safi]); dest;
 	     dest = bgp_route_next(dest)) {
 		table = bgp_dest_get_bgp_table_info(dest);
-		if (table != NULL) {
-			/* Special handling for 2-level routing
-			 * tables. */
-			if (safi == SAFI_MPLS_VPN || safi == SAFI_ENCAP
-			    || safi == SAFI_EVPN) {
-				for (ndest = bgp_table_top(table); ndest;
-				     ndest = bgp_route_next(ndest))
-					bgp_process(bgp, ndest, afi, safi);
-			} else
-				bgp_process(bgp, dest, afi, safi);
+
+		if (!table)
+			continue;
+
+		/* Special handling for 2-level routing
+		 * tables. */
+		if (safi == SAFI_MPLS_VPN || safi == SAFI_ENCAP
+		    || safi == SAFI_EVPN) {
+			for (ndest = bgp_table_top(table); ndest;
+			     ndest = bgp_route_next(ndest)) {
+				for (pi = bgp_dest_get_bgp_path_info(ndest);
+				     (pi != NULL) && (next = pi->next, 1);
+				     pi = next)
+					bgp_process(bgp, ndest, pi, afi, safi);
+			}
+		} else {
+			for (pi = bgp_dest_get_bgp_path_info(dest);
+			     (pi != NULL) && (next = pi->next, 1); pi = next)
+				bgp_process(bgp, dest, pi, afi, safi);
 		}
 	}
 }
diff --git a/bgpd/rfapi/rfapi.c b/bgpd/rfapi/rfapi.c
index e9ed7224e2..836b10c845 100644
--- a/bgpd/rfapi/rfapi.c
+++ b/bgpd/rfapi/rfapi.c
@@ -482,7 +482,7 @@ void del_vnc_route(struct rfapi_descriptor *rfd,
 
 		bgp_aggregate_decrement(bgp, p, bpi, afi, safi);
 		bgp_path_info_delete(bn, bpi);
-		bgp_process(bgp, bn, afi, safi);
+		bgp_process(bgp, bn, bpi, afi, safi);
 	} else {
 		vnc_zlog_debug_verbose(
 			"%s: Couldn't find route (safi=%d) at prefix %pFX",
@@ -1022,7 +1022,7 @@ void add_vnc_route(struct rfapi_descriptor *rfd, /* cookie, VPN UN addr, peer */
 
 			/* Process change. */
 			bgp_aggregate_increment(bgp, p, bpi, afi, safi);
-			bgp_process(bgp, bn, afi, safi);
+			bgp_process(bgp, bn, bpi, afi, safi);
 			bgp_dest_unlock_node(bn);
 
 			vnc_zlog_debug_any(
@@ -1065,7 +1065,7 @@ void add_vnc_route(struct rfapi_descriptor *rfd, /* cookie, VPN UN addr, peer */
 	}
 
 	bgp_dest_unlock_node(bn);
-	bgp_process(bgp, bn, afi, safi);
+	bgp_process(bgp, bn, new, afi, safi);
 
 	vnc_zlog_debug_any(
 		"%s: Added route (safi=%s) at prefix %s (bn=%p, prd=%pRD)",
diff --git a/tests/bgpd/subdir.am b/tests/bgpd/subdir.am
index 5148e7e440..97845ec1aa 100644
--- a/tests/bgpd/subdir.am
+++ b/tests/bgpd/subdir.am
@@ -52,17 +52,6 @@ tests_bgpd_test_mp_attr_LDADD = $(BGP_TEST_LDADD)
 tests_bgpd_test_mp_attr_SOURCES = tests/bgpd/test_mp_attr.c
 EXTRA_DIST += tests/bgpd/test_mp_attr.py
 
-
-if BGPD
-check_PROGRAMS += tests/bgpd/test_mpath
-endif
-tests_bgpd_test_mpath_CFLAGS = $(TESTS_CFLAGS)
-tests_bgpd_test_mpath_CPPFLAGS = $(TESTS_CPPFLAGS)
-tests_bgpd_test_mpath_LDADD = $(BGP_TEST_LDADD)
-tests_bgpd_test_mpath_SOURCES = tests/bgpd/test_mpath.c
-EXTRA_DIST += tests/bgpd/test_mpath.py
-
-
 if BGPD
 check_PROGRAMS += tests/bgpd/test_packet
 endif
diff --git a/tests/bgpd/test_mpath.c b/tests/bgpd/test_mpath.c
deleted file mode 100644
index c20403f670..0000000000
--- a/tests/bgpd/test_mpath.c
+++ /dev/null
@@ -1,493 +0,0 @@
-/*
- * BGP Multipath Unit Test
- * Copyright (C) 2010 Google Inc.
- *
- * This file is part of Quagga
- *
- * Quagga is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
- *
- * Quagga is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; see the file COPYING; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include <zebra.h>
-
-#include "qobj.h"
-#include "vty.h"
-#include "stream.h"
-#include "privs.h"
-#include "linklist.h"
-#include "memory.h"
-#include "zclient.h"
-#include "queue.h"
-#include "filter.h"
-
-#include "bgpd/bgpd.h"
-#include "bgpd/bgp_table.h"
-#include "bgpd/bgp_route.h"
-#include "bgpd/bgp_attr.h"
-#include "bgpd/bgp_nexthop.h"
-#include "bgpd/bgp_mpath.h"
-#include "bgpd/bgp_evpn.h"
-#include "bgpd/bgp_network.h"
-
-#define VT100_RESET "\x1b[0m"
-#define VT100_RED "\x1b[31m"
-#define VT100_GREEN "\x1b[32m"
-#define VT100_YELLOW "\x1b[33m"
-#define OK VT100_GREEN "OK" VT100_RESET
-#define FAILED VT100_RED "failed" VT100_RESET
-
-#define TEST_PASSED 0
-#define TEST_FAILED -1
-
-#define EXPECT_TRUE(expr, res)                                                 \
-	if (!(expr)) {                                                         \
-		printf("Test failure in %s line %u: %s\n", __func__, __LINE__, \
-		       #expr);                                                 \
-		(res) = TEST_FAILED;                                           \
-	}
-
-typedef struct testcase_t__ testcase_t;
-
-typedef int (*test_setup_func)(testcase_t *);
-typedef int (*test_run_func)(testcase_t *);
-typedef int (*test_cleanup_func)(testcase_t *);
-
-struct testcase_t__ {
-	const char *desc;
-	void *test_data;
-	void *verify_data;
-	void *tmp_data;
-	test_setup_func setup;
-	test_run_func run;
-	test_cleanup_func cleanup;
-};
-
-/* need these to link in libbgp */
-struct thread_master *master = NULL;
-extern struct zclient *zclient;
-struct zebra_privs_t bgpd_privs = {
-	.user = NULL,
-	.group = NULL,
-	.vty_group = NULL,
-};
-
-static int tty = 0;
-
-/* Create fake bgp instance */
-static struct bgp *bgp_create_fake(as_t *as, const char *name)
-{
-	struct bgp *bgp;
-	afi_t afi;
-	safi_t safi;
-
-	if ((bgp = XCALLOC(MTYPE_BGP, sizeof(struct bgp))) == NULL)
-		return NULL;
-
-	bgp_lock(bgp);
-	// bgp->peer_self = peer_new (bgp);
-	// bgp->peer_self->host = XSTRDUP (MTYPE_BGP_PEER_HOST, "Static
-	// announcement");
-
-	bgp->peer = list_new();
-	// bgp->peer->cmp = (int (*)(void *, void *)) peer_cmp;
-
-	bgp->group = list_new();
-	// bgp->group->cmp = (int (*)(void *, void *)) peer_group_cmp;
-
-	bgp_evpn_init(bgp);
-	FOREACH_AFI_SAFI (afi, safi) {
-		bgp->route[afi][safi] = bgp_table_init(bgp, afi, safi);
-		bgp->aggregate[afi][safi] = bgp_table_init(bgp, afi, safi);
-		bgp->rib[afi][safi] = bgp_table_init(bgp, afi, safi);
-		bgp->maxpaths[afi][safi].maxpaths_ebgp = MULTIPATH_NUM;
-		bgp->maxpaths[afi][safi].maxpaths_ibgp = MULTIPATH_NUM;
-	}
-
-	bgp_scan_init(bgp);
-	bgp->default_local_pref = BGP_DEFAULT_LOCAL_PREF;
-	bgp->default_holdtime = BGP_DEFAULT_HOLDTIME;
-	bgp->default_keepalive = BGP_DEFAULT_KEEPALIVE;
-	bgp->restart_time = BGP_DEFAULT_RESTART_TIME;
-	bgp->stalepath_time = BGP_DEFAULT_STALEPATH_TIME;
-
-	bgp->as = *as;
-
-	if (name)
-		bgp->name = strdup(name);
-
-	return bgp;
-}
-
-/*=========================================================
- * Testcase for maximum-paths configuration
- */
-static int setup_bgp_cfg_maximum_paths(testcase_t *t)
-{
-	as_t asn = 1;
-	t->tmp_data = bgp_create_fake(&asn, NULL);
-	if (!t->tmp_data)
-		return -1;
-	return 0;
-}
-
-static int run_bgp_cfg_maximum_paths(testcase_t *t)
-{
-	afi_t afi;
-	safi_t safi;
-	struct bgp *bgp;
-	int api_result;
-	int test_result = TEST_PASSED;
-
-	bgp = t->tmp_data;
-	FOREACH_AFI_SAFI (afi, safi) {
-		/* test bgp_maximum_paths_set */
-		api_result = bgp_maximum_paths_set(bgp, afi, safi,
-						   BGP_PEER_EBGP, 10, 0);
-		EXPECT_TRUE(api_result == 0, test_result);
-		api_result = bgp_maximum_paths_set(bgp, afi, safi,
-						   BGP_PEER_IBGP, 10, 0);
-		EXPECT_TRUE(api_result == 0, test_result);
-		EXPECT_TRUE(bgp->maxpaths[afi][safi].maxpaths_ebgp == 10,
-			    test_result);
-		EXPECT_TRUE(bgp->maxpaths[afi][safi].maxpaths_ibgp == 10,
-			    test_result);
-
-		/* test bgp_maximum_paths_unset */
-		api_result =
-			bgp_maximum_paths_unset(bgp, afi, safi, BGP_PEER_EBGP);
-		EXPECT_TRUE(api_result == 0, test_result);
-		api_result =
-			bgp_maximum_paths_unset(bgp, afi, safi, BGP_PEER_IBGP);
-		EXPECT_TRUE(api_result == 0, test_result);
-		EXPECT_TRUE((bgp->maxpaths[afi][safi].maxpaths_ebgp
-			     == MULTIPATH_NUM),
-			    test_result);
-		EXPECT_TRUE((bgp->maxpaths[afi][safi].maxpaths_ibgp
-			     == MULTIPATH_NUM),
-			    test_result);
-	}
-
-	return test_result;
-}
-
-static int cleanup_bgp_cfg_maximum_paths(testcase_t *t)
-{
-	return bgp_delete((struct bgp *)t->tmp_data);
-}
-
-testcase_t test_bgp_cfg_maximum_paths = {
-	.desc = "Test bgp maximum-paths config",
-	.setup = setup_bgp_cfg_maximum_paths,
-	.run = run_bgp_cfg_maximum_paths,
-	.cleanup = cleanup_bgp_cfg_maximum_paths,
-};
-
-/*=========================================================
- * Testcase for bgp_mp_list
- */
-struct peer test_mp_list_peer[] = {
-	{.local_as = 1, .as = 2}, {.local_as = 1, .as = 2},
-	{.local_as = 1, .as = 2}, {.local_as = 1, .as = 2},
-	{.local_as = 1, .as = 2},
-};
-int test_mp_list_peer_count = array_size(test_mp_list_peer);
-struct attr test_mp_list_attr[4];
-struct bgp_path_info test_mp_list_info[] = {
-	{.peer = &test_mp_list_peer[0], .attr = &test_mp_list_attr[0]},
-	{.peer = &test_mp_list_peer[1], .attr = &test_mp_list_attr[1]},
-	{.peer = &test_mp_list_peer[2], .attr = &test_mp_list_attr[1]},
-	{.peer = &test_mp_list_peer[3], .attr = &test_mp_list_attr[2]},
-	{.peer = &test_mp_list_peer[4], .attr = &test_mp_list_attr[3]},
-};
-int test_mp_list_info_count = array_size(test_mp_list_info);
-
-static int setup_bgp_mp_list(testcase_t *t)
-{
-	test_mp_list_attr[0].nexthop.s_addr = 0x01010101;
-	test_mp_list_attr[1].nexthop.s_addr = 0x02020202;
-	test_mp_list_attr[2].nexthop.s_addr = 0x03030303;
-	test_mp_list_attr[3].nexthop.s_addr = 0x04040404;
-
-	if ((test_mp_list_peer[0].su_remote = sockunion_str2su("1.1.1.1"))
-	    == NULL)
-		return -1;
-	if ((test_mp_list_peer[1].su_remote = sockunion_str2su("2.2.2.2"))
-	    == NULL)
-		return -1;
-	if ((test_mp_list_peer[2].su_remote = sockunion_str2su("3.3.3.3"))
-	    == NULL)
-		return -1;
-	if ((test_mp_list_peer[3].su_remote = sockunion_str2su("4.4.4.4"))
-	    == NULL)
-		return -1;
-	if ((test_mp_list_peer[4].su_remote = sockunion_str2su("5.5.5.5"))
-	    == NULL)
-		return -1;
-
-	return 0;
-}
-
-static int run_bgp_mp_list(testcase_t *t)
-{
-	struct list mp_list;
-	struct listnode *mp_node;
-	struct bgp_path_info *info;
-	int i;
-	int test_result = TEST_PASSED;
-	bgp_mp_list_init(&mp_list);
-	EXPECT_TRUE(listcount(&mp_list) == 0, test_result);
-
-	bgp_mp_list_add(&mp_list, &test_mp_list_info[1]);
-	bgp_mp_list_add(&mp_list, &test_mp_list_info[4]);
-	bgp_mp_list_add(&mp_list, &test_mp_list_info[2]);
-	bgp_mp_list_add(&mp_list, &test_mp_list_info[3]);
-	bgp_mp_list_add(&mp_list, &test_mp_list_info[0]);
-
-	for (i = 0, mp_node = mp_list.head; i < test_mp_list_info_count;
-	     i++, mp_node = listnextnode(mp_node)) {
-		info = listgetdata(mp_node);
-		EXPECT_TRUE(info == &test_mp_list_info[i], test_result);
-	}
-
-	bgp_mp_list_clear(&mp_list);
-	EXPECT_TRUE(listcount(&mp_list) == 0, test_result);
-
-	return test_result;
-}
-
-static int cleanup_bgp_mp_list(testcase_t *t)
-{
-	int i;
-
-	for (i = 0; i < test_mp_list_peer_count; i++)
-		sockunion_free(test_mp_list_peer[i].su_remote);
-
-	return 0;
-}
-
-testcase_t test_bgp_mp_list = {
-	.desc = "Test bgp_mp_list",
-	.setup = setup_bgp_mp_list,
-	.run = run_bgp_mp_list,
-	.cleanup = cleanup_bgp_mp_list,
-};
-
-/*=========================================================
- * Testcase for bgp_path_info_mpath_update
- */
-
-struct bgp_node test_rn;
-
-static int setup_bgp_path_info_mpath_update(testcase_t *t)
-{
-	int i;
-	struct bgp *bgp;
-	struct bgp_table *rt;
-	struct route_node *rt_node;
-	as_t asn = 1;
-
-	t->tmp_data = bgp_create_fake(&asn, NULL);
-	if (!t->tmp_data)
-		return -1;
-
-	bgp = t->tmp_data;
-	rt = bgp->rib[AFI_IP][SAFI_UNICAST];
-
-	if (!rt)
-		return -1;
-
-	str2prefix("42.1.1.0/24", &test_rn.p);
-	rt_node = bgp_dest_to_rnode(&test_rn);
-	memcpy((struct route_table *)&rt_node->table, &rt->route_table,
-	       sizeof(struct route_table));
-	setup_bgp_mp_list(t);
-	for (i = 0; i < test_mp_list_info_count; i++)
-		bgp_path_info_add(&test_rn, &test_mp_list_info[i]);
-	return 0;
-}
-
-static int run_bgp_path_info_mpath_update(testcase_t *t)
-{
-	struct bgp_path_info *new_best, *old_best, *mpath;
-	struct list mp_list;
-	struct bgp_maxpaths_cfg mp_cfg = {3, 3};
-	int test_result = TEST_PASSED;
-	bgp_mp_list_init(&mp_list);
-	bgp_mp_list_add(&mp_list, &test_mp_list_info[4]);
-	bgp_mp_list_add(&mp_list, &test_mp_list_info[3]);
-	bgp_mp_list_add(&mp_list, &test_mp_list_info[0]);
-	bgp_mp_list_add(&mp_list, &test_mp_list_info[1]);
-	new_best = &test_mp_list_info[3];
-	old_best = NULL;
-	bgp_path_info_mpath_update(NULL, &test_rn, new_best, old_best, &mp_list,
-				   &mp_cfg);
-	bgp_mp_list_clear(&mp_list);
-	EXPECT_TRUE(bgp_path_info_mpath_count(new_best) == 2, test_result);
-	mpath = bgp_path_info_mpath_first(new_best);
-	EXPECT_TRUE(mpath == &test_mp_list_info[0], test_result);
-	EXPECT_TRUE(CHECK_FLAG(mpath->flags, BGP_PATH_MULTIPATH), test_result);
-	mpath = bgp_path_info_mpath_next(mpath);
-	EXPECT_TRUE(mpath == &test_mp_list_info[1], test_result);
-	EXPECT_TRUE(CHECK_FLAG(mpath->flags, BGP_PATH_MULTIPATH), test_result);
-
-	bgp_mp_list_add(&mp_list, &test_mp_list_info[0]);
-	bgp_mp_list_add(&mp_list, &test_mp_list_info[1]);
-	new_best = &test_mp_list_info[0];
-	old_best = &test_mp_list_info[3];
-	bgp_path_info_mpath_update(NULL, &test_rn, new_best, old_best, &mp_list,
-				   &mp_cfg);
-	bgp_mp_list_clear(&mp_list);
-	EXPECT_TRUE(bgp_path_info_mpath_count(new_best) == 1, test_result);
-	mpath = bgp_path_info_mpath_first(new_best);
-	EXPECT_TRUE(mpath == &test_mp_list_info[1], test_result);
-	EXPECT_TRUE(CHECK_FLAG(mpath->flags, BGP_PATH_MULTIPATH), test_result);
-	EXPECT_TRUE(!CHECK_FLAG(test_mp_list_info[0].flags, BGP_PATH_MULTIPATH),
-		    test_result);
-
-	return test_result;
-}
-
-static int cleanup_bgp_path_info_mpath_update(testcase_t *t)
-{
-	int i;
-
-	for (i = 0; i < test_mp_list_peer_count; i++)
-		sockunion_free(test_mp_list_peer[i].su_remote);
-
-	return bgp_delete((struct bgp *)t->tmp_data);
-}
-
-testcase_t test_bgp_path_info_mpath_update = {
-	.desc = "Test bgp_path_info_mpath_update",
-	.setup = setup_bgp_path_info_mpath_update,
-	.run = run_bgp_path_info_mpath_update,
-	.cleanup = cleanup_bgp_path_info_mpath_update,
-};
-
-/*=========================================================
- * Set up testcase vector
- */
-testcase_t *all_tests[] = {
-	&test_bgp_cfg_maximum_paths, &test_bgp_mp_list,
-	&test_bgp_path_info_mpath_update,
-};
-
-int all_tests_count = array_size(all_tests);
-
-/*=========================================================
- * Test Driver Functions
- */
-static int global_test_init(void)
-{
-	qobj_init();
-	master = thread_master_create(NULL);
-	zclient = zclient_new(master, &zclient_options_default, NULL, 0);
-	bgp_master_init(master, BGP_SOCKET_SNDBUF_SIZE, list_new());
-	vrf_init(NULL, NULL, NULL, NULL);
-	bgp_option_set(BGP_OPT_NO_LISTEN);
-
-	if (fileno(stdout) >= 0)
-		tty = isatty(fileno(stdout));
-	return 0;
-}
-
-static int global_test_cleanup(void)
-{
-	if (zclient != NULL)
-		zclient_free(zclient);
-	thread_master_free(master);
-	return 0;
-}
-
-static void display_result(testcase_t *test, int result)
-{
-	if (tty)
-		printf("%s: %s\n", test->desc,
-		       result == TEST_PASSED ? OK : FAILED);
-	else
-		printf("%s: %s\n", test->desc,
-		       result == TEST_PASSED ? "OK" : "FAILED");
-}
-
-static int setup_test(testcase_t *t)
-{
-	int res = 0;
-	if (t->setup)
-		res = t->setup(t);
-	return res;
-}
-
-static int cleanup_test(testcase_t *t)
-{
-	int res = 0;
-	if (t->cleanup)
-		res = t->cleanup(t);
-	return res;
-}
-
-static void run_tests(testcase_t *tests[], int num_tests, int *pass_count,
-		      int *fail_count)
-{
-	int test_index, result;
-	testcase_t *cur_test;
-
-	*pass_count = *fail_count = 0;
-
-	for (test_index = 0; test_index < num_tests; test_index++) {
-		cur_test = tests[test_index];
-		if (!cur_test->desc) {
-			printf("error: test %d has no description!\n",
-			       test_index);
-			continue;
-		}
-		if (!cur_test->run) {
-			printf("error: test %s has no run function!\n",
-			       cur_test->desc);
-			continue;
-		}
-		if (setup_test(cur_test) != 0) {
-			printf("error: setup failed for test %s\n",
-			       cur_test->desc);
-			continue;
-		}
-		result = cur_test->run(cur_test);
-		if (result == TEST_PASSED)
-			*pass_count += 1;
-		else
-			*fail_count += 1;
-		display_result(cur_test, result);
-		if (cleanup_test(cur_test) != 0) {
-			printf("error: cleanup failed for test %s\n",
-			       cur_test->desc);
-			continue;
-		}
-	}
-}
-
-int main(void)
-{
-	int pass_count, fail_count;
-	time_t cur_time;
-
-	time(&cur_time);
-	printf("BGP Multipath Tests Run at %s", ctime(&cur_time));
-	if (global_test_init() != 0) {
-		printf("Global init failed. Terminating.\n");
-		exit(1);
-	}
-	run_tests(all_tests, all_tests_count, &pass_count, &fail_count);
-	global_test_cleanup();
-	printf("Total pass/fail: %d/%d\n", pass_count, fail_count);
-	return fail_count;
-}
diff --git a/tests/bgpd/test_mpath.py b/tests/bgpd/test_mpath.py
deleted file mode 100644
index 582fd25c20..0000000000
--- a/tests/bgpd/test_mpath.py
+++ /dev/null
@@ -1,10 +0,0 @@
-import frrtest
-
-
-class TestMpath(frrtest.TestMultiOut):
-    program = "./test_mpath"
-
-
-TestMpath.okfail("bgp maximum-paths config")
-TestMpath.okfail("bgp_mp_list")
-TestMpath.okfail("bgp_path_info_mpath_update")
diff --git a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post4.1.ref b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post4.1.ref
index b2e8de5ce1..fca6cbed82 100644
--- a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post4.1.ref
+++ b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post4.1.ref
@@ -1,5 +1,5 @@
 BGP table version is 1, local router ID is 192.168.0.1, vrf id 0
-Status codes:  s suppressed, d damped, h history, * valid, > best, = multipath,
+Status codes:  s suppressed, d damped, h history, u unsorted, * valid, > best, = multipath,
                i internal, r RIB-failure, S Stale, R Removed
 Nexthop codes: @NNN nexthop's vrf id, < announce-nh-self
 Origin codes:  i - IGP, e - EGP, ? - incomplete
diff --git a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post5.0.ref b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post5.0.ref
index 7bee704182..bb10828815 100644
--- a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post5.0.ref
+++ b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post5.0.ref
@@ -1,5 +1,5 @@
 BGP table version is 1, local router ID is 192.168.0.1, vrf id 0
-Status codes:  s suppressed, d damped, h history, * valid, > best, = multipath,
+Status codes:  s suppressed, d damped, h history, u unsorted, * valid, > best, = multipath,
                i internal, r RIB-failure, S Stale, R Removed
 Nexthop codes: @NNN nexthop's vrf id, < announce-nh-self
 Origin codes:  i - IGP, e - EGP, ? - incomplete
diff --git a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post6.1.ref b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post6.1.ref
index 31071e760d..04ad86fbb0 100644
--- a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post6.1.ref
+++ b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post6.1.ref
@@ -1,6 +1,6 @@
 BGP table version is 1, local router ID is 192.168.0.1, vrf id 0
 Default local pref 100, local AS 100
-Status codes:  s suppressed, d damped, h history, * valid, > best, = multipath,
+Status codes:  s suppressed, d damped, h history, u unsorted, * valid, > best, = multipath,
                i internal, r RIB-failure, S Stale, R Removed
 Nexthop codes: @NNN nexthop's vrf id, < announce-nh-self
 Origin codes:  i - IGP, e - EGP, ? - incomplete
diff --git a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4.ref b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4.ref
index 53c4793bf4..ca95a1671b 100644
--- a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4.ref
+++ b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4.ref
@@ -1,5 +1,5 @@
 BGP table version is 1, local router ID is 192.168.0.1
-Status codes: s suppressed, d damped, h history, * valid, > best, = multipath,
+Status codes: s suppressed, d damped, h history, u unsorted, * valid, > best, = multipath,
               i internal, r RIB-failure, S Stale, R Removed
 Origin codes: i - IGP, e - EGP, ? - incomplete
 
diff --git a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6-post4.1.ref b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6-post4.1.ref
index fe3f0720d8..f1b09264b2 100644
--- a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6-post4.1.ref
+++ b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6-post4.1.ref
@@ -1,5 +1,5 @@
 BGP table version is 1, local router ID is 192.168.0.1, vrf id 0
-Status codes:  s suppressed, d damped, h history, * valid, > best, = multipath,
+Status codes:  s suppressed, d damped, h history, u unsorted, * valid, > best, = multipath,
                i internal, r RIB-failure, S Stale, R Removed
 Nexthop codes: @NNN nexthop's vrf id, < announce-nh-self
 Origin codes:  i - IGP, e - EGP, ? - incomplete
diff --git a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6.ref b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6.ref
index 363b4f5349..278fc2dad2 100644
--- a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6.ref
+++ b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6.ref
@@ -1,5 +1,5 @@
 BGP table version is 1, local router ID is 192.168.0.1
-Status codes: s suppressed, d damped, h history, * valid, > best, = multipath,
+Status codes: s suppressed, d damped, h history, u unsorted, * valid, > best, = multipath,
               i internal, r RIB-failure, S Stale, R Removed
 Origin codes: i - IGP, e - EGP, ? - incomplete
 
diff --git a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6_post6.1.ref b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6_post6.1.ref
index 8c3229b45d..88f3eac178 100644
--- a/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6_post6.1.ref
+++ b/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6_post6.1.ref
@@ -1,6 +1,6 @@
 BGP table version is 1, local router ID is 192.168.0.1, vrf id 0
 Default local pref 100, local AS 100
-Status codes:  s suppressed, d damped, h history, * valid, > best, = multipath,
+Status codes:  s suppressed, d damped, h history, u unsorted, * valid, > best, = multipath,
                i internal, r RIB-failure, S Stale, R Removed
 Nexthop codes: @NNN nexthop's vrf id, < announce-nh-self
 Origin codes:  i - IGP, e - EGP, ? - incomplete
-- 
2.43.2

