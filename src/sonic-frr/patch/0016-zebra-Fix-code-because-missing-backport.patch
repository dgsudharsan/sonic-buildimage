From 4b3e93a43c0d6322845f54aa0eab1bfac2cd50de Mon Sep 17 00:00:00 2001
From: Donald Sharp <sharpd@nvidia.com>
Date: Thu, 15 Dec 2022 10:52:38 -0500
Subject: [PATCH] From 0104413e893f3e2d41da101b6788aea240e5a21a Mon Sep 17
 00:00:00 2001 Subject: [PATCH 8/8] zebra: Fix code because missing backport

The commit:
commit 07fd1f7e9420efd480e85a9ab72b88fff274f791
Author: Donald Sharp <sharpd@nvidia.com>
Date:   Tue Aug 9 20:07:09 2022 -0400

    zebra: use rib_add_multipath in rt_netlink.c

    The new route code path was using a combination of
    both rib_add() and rib_add_multipath() let's clean
    it up some to use rib_add_multipath()

    Signed-off-by: Donald Sharp <sharpd@nvidia.com>

Abstracted the calling of rib_add and rib_add_multipath in
netlink_route_change_read_unicast to just calling rib_add_multipath
one time.  Since this commit was not backported the netlink_route_change_read_unicast
function had an additional rib_add that is not going through the new dplane
code to make a decision point about how to send up the message.

Make it so the non multipath case uses the new decision point.

Signed-off-by: Donald Sharp <sharpd@nvidia.com>
---
 zebra/rt_netlink.c | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/zebra/rt_netlink.c b/zebra/rt_netlink.c
index c4cddd3f7..562b4a23c 100644
--- a/zebra/rt_netlink.c
+++ b/zebra/rt_netlink.c
@@ -943,11 +943,23 @@ int netlink_route_change_read_unicast_internal(struct nlmsghdr *h,
 		re = zebra_rib_route_entry_new(vrf_id, proto, 0, flags, nhe_id,
 					       table, metric, mtu, distance,
 					       tag);
+		re = XCALLOC(MTYPE_RE, sizeof(struct route_entry));
+		re->type = proto;
+		re->distance = distance;
+		re->flags = flags;
+		re->metric = metric;
+		re->mtu = mtu;
+		re->vrf_id = vrf_id;
+		re->table = table;
+		re->uptime = monotime(NULL);
+		re->tag = tag;
+		re->nhe_id = nhe_id;
+
 		if (!nhe_id)
 			ng = nexthop_group_new();
 
 		if (!tb[RTA_MULTIPATH]) {
-			struct nexthop *nexthop, nh;
+			struct nexthop *nexthop, nh = {0};
 
 			if (!nhe_id) {
 				nh = parse_nexthop_unicast(
@@ -958,8 +970,11 @@ int netlink_route_change_read_unicast_internal(struct nlmsghdr *h,
 				*nexthop = nh;
 				nexthop_group_add_sorted(ng, nexthop);
 			}
+			dplane_rib_add_multipath(afi, SAFI_UNICAST, &p, &src_p,
+						 re, ng, startup, ctx);
 		} else {
 			/* This is a multipath route */
+			struct nexthop_group *ng = NULL;
 			struct rtnexthop *rtnh =
 				(struct rtnexthop *)RTA_DATA(tb[RTA_MULTIPATH]);
 
-- 
2.17.1

